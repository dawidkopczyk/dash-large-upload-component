window["dash_large_upload_component"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8zMjBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz9hMTVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLHlGQUE0QjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar has = Function.call.bind(Object.prototype.hasOwnProperty);\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcz9iMDcyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsa0RBQVU7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLDREQUFlOztBQUVwQywyQkFBMkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDL0QscUJBQXFCLG1CQUFPLENBQUMscUVBQWtCOztBQUUvQztBQUNBOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyw0RkFBNEYsU0FBTTtBQUM3STtBQUNBOztBQUVBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz9kN2JjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLGtEQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBMkI7QUFDdEQsQ0FBQyxNQUFNLEVBSU4iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/NTliMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.8.6\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' ||\n  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n              default:\n                return $$typeof;\n            }\n        }\n      case REACT_LAZY_TYPE:\n      case REACT_MEMO_TYPE:\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\n\n// AsyncMode is deprecated along with isAsyncMode\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\n\nvar hasWarnedAboutDeprecatedIsAsyncMode = false;\n\n// AsyncMode should be deprecated\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true;\n      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.typeOf = typeOf;\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isValidElementType = isValidElementType;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzP2E4ZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7OztBQUliLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYzs7QUFFNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi44LjZcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlO1xudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKTtcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93UHJpb3JpdHlXYXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcblxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7XG5cbi8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7XG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuICB9KSgpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/cjs/react-is.development.js\n");

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/NGNlYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUM7QUFDRCxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBK0I7QUFDMUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-is/index.js\n");

/***/ }),

/***/ "./node_modules/resumablejs/resumable.js":
/*!***********************************************!*\
  !*** ./node_modules/resumablejs/resumable.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n* MIT Licensed\n* http://www.23developer.com/opensource\n* http://github.com/23/resumable.js\n* Steffen Tiedemann Christensen, steffen@23company.com\n*/\n\n(function(){\n\"use strict\";\n\n  var Resumable = function(opts){\n    if ( !(this instanceof Resumable) ) {\n      return new Resumable(opts);\n    }\n    this.version = 1.0;\n    // SUPPORTED BY BROWSER?\n    // Check if these features are support by the browser:\n    // - File object type\n    // - Blob object type\n    // - FileList object type\n    // - slicing files\n    this.support = (\n                   (typeof(File)!=='undefined')\n                   &&\n                   (typeof(Blob)!=='undefined')\n                   &&\n                   (typeof(FileList)!=='undefined')\n                   &&\n                   (!!Blob.prototype.webkitSlice||!!Blob.prototype.mozSlice||!!Blob.prototype.slice||false)\n                   );\n    if(!this.support) return(false);\n\n\n    // PROPERTIES\n    var $ = this;\n    $.files = [];\n    $.defaults = {\n      chunkSize:1*1024*1024,\n      forceChunkSize:false,\n      simultaneousUploads:3,\n      fileParameterName:'file',\n      chunkNumberParameterName: 'resumableChunkNumber',\n      chunkSizeParameterName: 'resumableChunkSize',\n      currentChunkSizeParameterName: 'resumableCurrentChunkSize',\n      totalSizeParameterName: 'resumableTotalSize',\n      typeParameterName: 'resumableType',\n      identifierParameterName: 'resumableIdentifier',\n      fileNameParameterName: 'resumableFilename',\n      relativePathParameterName: 'resumableRelativePath',\n      totalChunksParameterName: 'resumableTotalChunks',\n      throttleProgressCallbacks: 0.5,\n      query:{},\n      headers:{},\n      preprocess:null,\n      method:'multipart',\n      uploadMethod: 'POST',\n      testMethod: 'GET',\n      prioritizeFirstAndLastChunk:false,\n      target:'/',\n      testTarget: null,\n      parameterNamespace:'',\n      testChunks:true,\n      generateUniqueIdentifier:null,\n      getTarget:null,\n      maxChunkRetries:100,\n      chunkRetryInterval:undefined,\n      permanentErrors:[400, 404, 415, 500, 501],\n      maxFiles:undefined,\n      withCredentials:false,\n      xhrTimeout:0,\n      clearInput:true,\n      chunkFormat:'blob',\n      setChunkTypeFromFile:false,\n      maxFilesErrorCallback:function (files, errorCount) {\n        var maxFiles = $.getOpt('maxFiles');\n        alert('Please upload no more than ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');\n      },\n      minFileSize:1,\n      minFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too small, please upload files larger than ' + $h.formatSize($.getOpt('minFileSize')) + '.');\n      },\n      maxFileSize:undefined,\n      maxFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too large, please upload files less than ' + $h.formatSize($.getOpt('maxFileSize')) + '.');\n      },\n      fileType: [],\n      fileTypeErrorCallback: function(file, errorCount) {\n        alert(file.fileName||file.name +' has type not allowed, please upload files of type ' + $.getOpt('fileType') + '.');\n      }\n    };\n    $.opts = opts||{};\n    $.getOpt = function(o) {\n      var $opt = this;\n      // Get multiple option if passed an array\n      if(o instanceof Array) {\n        var options = {};\n        $h.each(o, function(option){\n          options[option] = $opt.getOpt(option);\n        });\n        return options;\n      }\n      // Otherwise, just return a simple option\n      if ($opt instanceof ResumableChunk) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.fileObj; }\n      }\n      if ($opt instanceof ResumableFile) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.resumableObj; }\n      }\n      if ($opt instanceof Resumable) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { return $opt.defaults[o]; }\n      }\n    };\n\n    // EVENTS\n    // catchAll(event, ...)\n    // fileSuccess(file), fileProgress(file), fileAdded(file, event), filesAdded(files, filesSkipped), fileRetry(file),\n    // fileError(file, message), complete(), progress(), error(message, file), pause()\n    $.events = [];\n    $.on = function(event,callback){\n      $.events.push(event.toLowerCase(), callback);\n    };\n    $.fire = function(){\n      // `arguments` is an object, not array, in FF, so:\n      var args = [];\n      for (var i=0; i<arguments.length; i++) args.push(arguments[i]);\n      // Find event listeners, and support pseudo-event `catchAll`\n      var event = args[0].toLowerCase();\n      for (var i=0; i<=$.events.length; i+=2) {\n        if($.events[i]==event) $.events[i+1].apply($,args.slice(1));\n        if($.events[i]=='catchall') $.events[i+1].apply(null,args);\n      }\n      if(event=='fileerror') $.fire('error', args[2], args[1]);\n      if(event=='fileprogress') $.fire('progress');\n    };\n\n\n    // INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)\n    var $h = {\n      stopEvent: function(e){\n        e.stopPropagation();\n        e.preventDefault();\n      },\n      each: function(o,callback){\n        if(typeof(o.length)!=='undefined') {\n          for (var i=0; i<o.length; i++) {\n            // Array or FileList\n            if(callback(o[i])===false) return;\n          }\n        } else {\n          for (i in o) {\n            // Object\n            if(callback(i,o[i])===false) return;\n          }\n        }\n      },\n      generateUniqueIdentifier:function(file, event){\n        var custom = $.getOpt('generateUniqueIdentifier');\n        if(typeof custom === 'function') {\n          return custom(file, event);\n        }\n        var relativePath = file.webkitRelativePath||file.fileName||file.name; // Some confusion in different versions of Firefox\n        var size = file.size;\n        return(size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));\n      },\n      contains:function(array,test) {\n        var result = false;\n\n        $h.each(array, function(value) {\n          if (value == test) {\n            result = true;\n            return false;\n          }\n          return true;\n        });\n\n        return result;\n      },\n      formatSize:function(size){\n        if(size<1024) {\n          return size + ' bytes';\n        } else if(size<1024*1024) {\n          return (size/1024.0).toFixed(0) + ' KB';\n        } else if(size<1024*1024*1024) {\n          return (size/1024.0/1024.0).toFixed(1) + ' MB';\n        } else {\n          return (size/1024.0/1024.0/1024.0).toFixed(1) + ' GB';\n        }\n      },\n      getTarget:function(request, params){\n        var target = $.getOpt('target');\n\n        if (request === 'test' && $.getOpt('testTarget')) {\n          target = $.getOpt('testTarget') === '/' ? $.getOpt('target') : $.getOpt('testTarget');\n        }\n\n        if (typeof target === 'function') {\n          return target(params);\n        }\n\n        var separator = target.indexOf('?') < 0 ? '?' : '&';\n        var joinedParams = params.join('&');\n\n        return target + separator + joinedParams;\n      }\n    };\n\n    var onDrop = function(event){\n      $h.stopEvent(event);\n\n      //handle dropped things as items if we can (this lets us deal with folders nicer in some cases)\n      if (event.dataTransfer && event.dataTransfer.items) {\n        loadFiles(event.dataTransfer.items, event);\n      }\n      //else handle them as files\n      else if (event.dataTransfer && event.dataTransfer.files) {\n        loadFiles(event.dataTransfer.files, event);\n      }\n    };\n    var preventDefault = function(e) {\n      e.preventDefault();\n    };\n\n    /**\n     * processes a single upload item (file or directory)\n     * @param {Object} item item to upload, may be file or directory entry\n     * @param {string} path current file path\n     * @param {File[]} items list of files to append new items to\n     * @param {Function} cb callback invoked when item is processed\n     */\n    function processItem(item, path, items, cb) {\n      var entry;\n      if(item.isFile){\n        // file provided\n        return item.file(function(file){\n          file.relativePath = path + file.name;\n          items.push(file);\n          cb();\n        });\n      }else if(item.isDirectory){\n        // item is already a directory entry, just assign\n        entry = item;\n      }else if(item instanceof File) {\n        items.push(item);\n      }\n      if('function' === typeof item.webkitGetAsEntry){\n        // get entry from file object\n        entry = item.webkitGetAsEntry();\n      }\n      if(entry && entry.isDirectory){\n        // directory provided, process it\n        return processDirectory(entry, path + entry.name + '/', items, cb);\n      }\n      if('function' === typeof item.getAsFile){\n        // item represents a File object, convert it\n        item = item.getAsFile();\n        if(item instanceof File) {\n          item.relativePath = path + item.name;\n          items.push(item);\n        }\n      }\n      cb(); // indicate processing is done\n    }\n\n\n    /**\n     * cps-style list iteration.\n     * invokes all functions in list and waits for their callback to be\n     * triggered.\n     * @param  {Function[]}   items list of functions expecting callback parameter\n     * @param  {Function} cb    callback to trigger after the last callback has been invoked\n     */\n    function processCallbacks(items, cb){\n      if(!items || items.length === 0){\n        // empty or no list, invoke callback\n        return cb();\n      }\n      // invoke current function, pass the next part as continuation\n      items[0](function(){\n        processCallbacks(items.slice(1), cb);\n      });\n    }\n\n    /**\n     * recursively traverse directory and collect files to upload\n     * @param  {Object}   directory directory to process\n     * @param  {string}   path      current path\n     * @param  {File[]}   items     target list of items\n     * @param  {Function} cb        callback invoked after traversing directory\n     */\n    function processDirectory (directory, path, items, cb) {\n      var dirReader = directory.createReader();\n      dirReader.readEntries(function(entries){\n        if(!entries.length){\n          // empty directory, skip\n          return cb();\n        }\n        // process all conversion callbacks, finally invoke own one\n        processCallbacks(\n          entries.map(function(entry){\n            // bind all properties except for callback\n            return processItem.bind(null, entry, path, items);\n          }),\n          cb\n        );\n      });\n    }\n\n    /**\n     * process items to extract files to be uploaded\n     * @param  {File[]} items items to process\n     * @param  {Event} event event that led to upload\n     */\n    function loadFiles(items, event) {\n      if(!items.length){\n        return; // nothing to do\n      }\n      $.fire('beforeAdd');\n      var files = [];\n      processCallbacks(\n          Array.prototype.map.call(items, function(item){\n            // bind all properties except for callback\n            return processItem.bind(null, item, \"\", files);\n          }),\n          function(){\n            if(files.length){\n              // at least one file found\n              appendFilesFromFileList(files, event);\n            }\n          }\n      );\n    };\n\n    var appendFilesFromFileList = function(fileList, event){\n      // check for uploading too many files\n      var errorCount = 0;\n      var o = $.getOpt(['maxFiles', 'minFileSize', 'maxFileSize', 'maxFilesErrorCallback', 'minFileSizeErrorCallback', 'maxFileSizeErrorCallback', 'fileType', 'fileTypeErrorCallback']);\n      if (typeof(o.maxFiles)!=='undefined' && o.maxFiles<(fileList.length+$.files.length)) {\n        // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file\n        if (o.maxFiles===1 && $.files.length===1 && fileList.length===1) {\n          $.removeFile($.files[0]);\n        } else {\n          o.maxFilesErrorCallback(fileList, errorCount++);\n          return false;\n        }\n      }\n      var files = [], filesSkipped = [], remaining = fileList.length;\n      var decreaseReamining = function(){\n        if(!--remaining){\n          // all files processed, trigger event\n          if(!files.length && !filesSkipped.length){\n            // no succeeded files, just skip\n            return;\n          }\n          window.setTimeout(function(){\n            $.fire('filesAdded', files, filesSkipped);\n          },0);\n        }\n      };\n      $h.each(fileList, function(file){\n        var fileName = file.name;\n        if(o.fileType.length > 0){\n          var fileTypeFound = false;\n          for(var index in o.fileType){\n            var extension = '.' + o.fileType[index];\n\t\t\tif(fileName.toLowerCase().indexOf(extension.toLowerCase(), fileName.length - extension.length) !== -1){\n              fileTypeFound = true;\n              break;\n            }\n          }\n          if (!fileTypeFound) {\n            o.fileTypeErrorCallback(file, errorCount++);\n            return false;\n          }\n        }\n\n        if (typeof(o.minFileSize)!=='undefined' && file.size<o.minFileSize) {\n          o.minFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n        if (typeof(o.maxFileSize)!=='undefined' && file.size>o.maxFileSize) {\n          o.maxFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n\n        function addFile(uniqueIdentifier){\n          if (!$.getFromUniqueIdentifier(uniqueIdentifier)) {(function(){\n            file.uniqueIdentifier = uniqueIdentifier;\n            var f = new ResumableFile($, file, uniqueIdentifier);\n            $.files.push(f);\n            files.push(f);\n            f.container = (typeof event != 'undefined' ? event.srcElement : null);\n            window.setTimeout(function(){\n              $.fire('fileAdded', f, event)\n            },0);\n          })()} else {\n            filesSkipped.push(file);\n          };\n          decreaseReamining();\n        }\n        // directories have size == 0\n        var uniqueIdentifier = $h.generateUniqueIdentifier(file, event);\n        if(uniqueIdentifier && typeof uniqueIdentifier.then === 'function'){\n          // Promise or Promise-like object provided as unique identifier\n          uniqueIdentifier\n          .then(\n            function(uniqueIdentifier){\n              // unique identifier generation succeeded\n              addFile(uniqueIdentifier);\n            },\n           function(){\n              // unique identifier generation failed\n              // skip further processing, only decrease file count\n              decreaseReamining();\n            }\n          );\n        }else{\n          // non-Promise provided as unique identifier, process synchronously\n          addFile(uniqueIdentifier);\n        }\n      });\n    };\n\n    // INTERNAL OBJECT TYPES\n    function ResumableFile(resumableObj, file, uniqueIdentifier){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $._prevProgress = 0;\n      $.resumableObj = resumableObj;\n      $.file = file;\n      $.fileName = file.fileName||file.name; // Some confusion in different versions of Firefox\n      $.size = file.size;\n      $.relativePath = file.relativePath || file.webkitRelativePath || $.fileName;\n      $.uniqueIdentifier = uniqueIdentifier;\n      $._pause = false;\n      $.container = '';\n      var _error = uniqueIdentifier !== undefined;\n\n      // Callback when something happens within the chunk\n      var chunkEvent = function(event, message){\n        // event can be 'progress', 'success', 'error' or 'retry'\n        switch(event){\n        case 'progress':\n          $.resumableObj.fire('fileProgress', $, message);\n          break;\n        case 'error':\n          $.abort();\n          _error = true;\n          $.chunks = [];\n          $.resumableObj.fire('fileError', $, message);\n          break;\n        case 'success':\n          if(_error) return;\n          $.resumableObj.fire('fileProgress', $); // it's at least progress\n          if($.isComplete()) {\n            $.resumableObj.fire('fileSuccess', $, message);\n          }\n          break;\n        case 'retry':\n          $.resumableObj.fire('fileRetry', $);\n          break;\n        }\n      };\n\n      // Main code to set up a file object with chunks,\n      // packaged to be able to handle retries if needed.\n      $.chunks = [];\n      $.abort = function(){\n        // Stop current uploads\n        var abortCount = 0;\n        $h.each($.chunks, function(c){\n          if(c.status()=='uploading') {\n            c.abort();\n            abortCount++;\n          }\n        });\n        if(abortCount>0) $.resumableObj.fire('fileProgress', $);\n      };\n      $.cancel = function(){\n        // Reset this file to be void\n        var _chunks = $.chunks;\n        $.chunks = [];\n        // Stop current uploads\n        $h.each(_chunks, function(c){\n          if(c.status()=='uploading')  {\n            c.abort();\n            $.resumableObj.uploadNextChunk();\n          }\n        });\n        $.resumableObj.removeFile($);\n        $.resumableObj.fire('fileProgress', $);\n      };\n      $.retry = function(){\n        $.bootstrap();\n        var firedRetry = false;\n        $.resumableObj.on('chunkingComplete', function(){\n          if(!firedRetry) $.resumableObj.upload();\n          firedRetry = true;\n        });\n      };\n      $.bootstrap = function(){\n        $.abort();\n        _error = false;\n        // Rebuild stack of chunks from file\n        $.chunks = [];\n        $._prevProgress = 0;\n        var round = $.getOpt('forceChunkSize') ? Math.ceil : Math.floor;\n        var maxOffset = Math.max(round($.file.size/$.getOpt('chunkSize')),1);\n        for (var offset=0; offset<maxOffset; offset++) {(function(offset){\n            window.setTimeout(function(){\n                $.chunks.push(new ResumableChunk($.resumableObj, $, offset, chunkEvent));\n                $.resumableObj.fire('chunkingProgress',$,offset/maxOffset);\n            },0);\n        })(offset)}\n        window.setTimeout(function(){\n            $.resumableObj.fire('chunkingComplete',$);\n        },0);\n      };\n      $.progress = function(){\n        if(_error) return(1);\n        // Sum up progress across everything\n        var ret = 0;\n        var error = false;\n        $h.each($.chunks, function(c){\n          if(c.status()=='error') error = true;\n          ret += c.progress(true); // get chunk progress relative to entire file\n        });\n        ret = (error ? 1 : (ret>0.99999 ? 1 : ret));\n        ret = Math.max($._prevProgress, ret); // We don't want to lose percentages when an upload is paused\n        $._prevProgress = ret;\n        return(ret);\n      };\n      $.isUploading = function(){\n        var uploading = false;\n        $h.each($.chunks, function(chunk){\n          if(chunk.status()=='uploading') {\n            uploading = true;\n            return(false);\n          }\n        });\n        return(uploading);\n      };\n      $.isComplete = function(){\n        var outstanding = false;\n        $h.each($.chunks, function(chunk){\n          var status = chunk.status();\n          if(status=='pending' || status=='uploading' || chunk.preprocessState === 1) {\n            outstanding = true;\n            return(false);\n          }\n        });\n        return(!outstanding);\n      };\n      $.pause = function(pause){\n          if(typeof(pause)==='undefined'){\n              $._pause = ($._pause ? false : true);\n          }else{\n              $._pause = pause;\n          }\n      };\n      $.isPaused = function() {\n        return $._pause;\n      };\n\n\n      // Bootstrap and return\n      $.resumableObj.fire('chunkingStart', $);\n      $.bootstrap();\n      return(this);\n    }\n\n\n    function ResumableChunk(resumableObj, fileObj, offset, callback){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $.resumableObj = resumableObj;\n      $.fileObj = fileObj;\n      $.fileObjSize = fileObj.size;\n      $.fileObjType = fileObj.file.type;\n      $.offset = offset;\n      $.callback = callback;\n      $.lastProgressCallback = (new Date);\n      $.tested = false;\n      $.retries = 0;\n      $.pendingRetry = false;\n      $.preprocessState = 0; // 0 = unprocessed, 1 = processing, 2 = finished\n\n      // Computed properties\n      var chunkSize = $.getOpt('chunkSize');\n      $.loaded = 0;\n      $.startByte = $.offset*chunkSize;\n      $.endByte = Math.min($.fileObjSize, ($.offset+1)*chunkSize);\n      if ($.fileObjSize-$.endByte < chunkSize && !$.getOpt('forceChunkSize')) {\n        // The last chunk will be bigger than the chunk size, but less than 2*chunkSize\n        $.endByte = $.fileObjSize;\n      }\n      $.xhr = null;\n\n      // test() makes a GET request without any data to see if the chunk has already been uploaded in a previous session\n      $.test = function(){\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        var testHandler = function(e){\n          $.tested = true;\n          var status = $.status();\n          if(status=='success') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.send();\n          }\n        };\n        $.xhr.addEventListener('load', testHandler, false);\n        $.xhr.addEventListener('error', testHandler, false);\n        $.xhr.addEventListener('timeout', testHandler, false);\n\n        // Add data from the query options\n        var params = [];\n        var parameterNamespace = $.getOpt('parameterNamespace');\n        var customQuery = $.getOpt('query');\n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          params.push([encodeURIComponent(parameterNamespace+k), encodeURIComponent(v)].join('='));\n        });\n        // Add extra data to identify chunk\n        params = params.concat(\n          [\n            // define key/value pairs for additional parameters\n            ['chunkNumberParameterName', $.offset + 1],\n            ['chunkSizeParameterName', $.getOpt('chunkSize')],\n            ['currentChunkSizeParameterName', $.endByte - $.startByte],\n            ['totalSizeParameterName', $.fileObjSize],\n            ['typeParameterName', $.fileObjType],\n            ['identifierParameterName', $.fileObj.uniqueIdentifier],\n            ['fileNameParameterName', $.fileObj.fileName],\n            ['relativePathParameterName', $.fileObj.relativePath],\n            ['totalChunksParameterName', $.fileObj.chunks.length]\n          ].filter(function(pair){\n            // include items that resolve to truthy values\n            // i.e. exclude false, null, undefined and empty strings\n            return $.getOpt(pair[0]);\n          })\n          .map(function(pair){\n            // map each key/value pair to its final form\n            return [\n              parameterNamespace + $.getOpt(pair[0]),\n              encodeURIComponent(pair[1])\n            ].join('=');\n          })\n        );\n        // Append the relevant chunk and send it\n        $.xhr.open($.getOpt('testMethod'), $h.getTarget('test', params));\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        var customHeaders = $.getOpt('headers');\n        if(typeof customHeaders === 'function') {\n          customHeaders = customHeaders($.fileObj, $);\n        }\n        $h.each(customHeaders, function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n        $.xhr.send(null);\n      };\n\n      $.preprocessFinished = function(){\n        $.preprocessState = 2;\n        $.send();\n      };\n\n      // send() uploads the actual data in a POST call\n      $.send = function(){\n        var preprocess = $.getOpt('preprocess');\n        if(typeof preprocess === 'function') {\n          switch($.preprocessState) {\n          case 0: $.preprocessState = 1; preprocess($); return;\n          case 1: return;\n          case 2: break;\n          }\n        }\n        if($.getOpt('testChunks') && !$.tested) {\n          $.test();\n          return;\n        }\n\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        // Progress\n        $.xhr.upload.addEventListener('progress', function(e){\n          if( (new Date) - $.lastProgressCallback > $.getOpt('throttleProgressCallbacks') * 1000 ) {\n            $.callback('progress');\n            $.lastProgressCallback = (new Date);\n          }\n          $.loaded=e.loaded||0;\n        }, false);\n        $.loaded = 0;\n        $.pendingRetry = false;\n        $.callback('progress');\n\n        // Done (either done, failed or retry)\n        var doneHandler = function(e){\n          var status = $.status();\n          if(status=='success'||status=='error') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.callback('retry', $.message());\n            $.abort();\n            $.retries++;\n            var retryInterval = $.getOpt('chunkRetryInterval');\n            if(retryInterval !== undefined) {\n              $.pendingRetry = true;\n              setTimeout($.send, retryInterval);\n            } else {\n              $.send();\n            }\n          }\n        };\n        $.xhr.addEventListener('load', doneHandler, false);\n        $.xhr.addEventListener('error', doneHandler, false);\n        $.xhr.addEventListener('timeout', doneHandler, false);\n\n        // Set up the basic query data from Resumable\n        var query = [\n          ['chunkNumberParameterName', $.offset + 1],\n          ['chunkSizeParameterName', $.getOpt('chunkSize')],\n          ['currentChunkSizeParameterName', $.endByte - $.startByte],\n          ['totalSizeParameterName', $.fileObjSize],\n          ['typeParameterName', $.fileObjType],\n          ['identifierParameterName', $.fileObj.uniqueIdentifier],\n          ['fileNameParameterName', $.fileObj.fileName],\n          ['relativePathParameterName', $.fileObj.relativePath],\n          ['totalChunksParameterName', $.fileObj.chunks.length],\n        ].filter(function(pair){\n          // include items that resolve to truthy values\n          // i.e. exclude false, null, undefined and empty strings\n          return $.getOpt(pair[0]);\n        })\n        .reduce(function(query, pair){\n          // assign query key/value\n          query[$.getOpt(pair[0])] = pair[1];\n          return query;\n        }, {});\n        // Mix in custom data\n        var customQuery = $.getOpt('query');\n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          query[k] = v;\n        });\n\n        var func = ($.fileObj.file.slice ? 'slice' : ($.fileObj.file.mozSlice ? 'mozSlice' : ($.fileObj.file.webkitSlice ? 'webkitSlice' : 'slice')));\n        var bytes = $.fileObj.file[func]($.startByte, $.endByte, $.getOpt('setChunkTypeFromFile') ? $.fileObj.file.type : \"\");\n        var data = null;\n        var params = [];\n\n        var parameterNamespace = $.getOpt('parameterNamespace');\n                if ($.getOpt('method') === 'octet') {\n                    // Add data from the query options\n                    data = bytes;\n                    $h.each(query, function (k, v) {\n                        params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join('='));\n                    });\n                } else {\n                    // Add data from the query options\n                    data = new FormData();\n                    $h.each(query, function (k, v) {\n                        data.append(parameterNamespace + k, v);\n                        params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join('='));\n                    });\n                    if ($.getOpt('chunkFormat') == 'blob') {\n                        data.append(parameterNamespace + $.getOpt('fileParameterName'), bytes, $.fileObj.fileName);\n                    }\n                    else if ($.getOpt('chunkFormat') == 'base64') {\n                        var fr = new FileReader();\n                        fr.onload = function (e) {\n                            data.append(parameterNamespace + $.getOpt('fileParameterName'), fr.result);\n                            $.xhr.send(data);\n                        }\n                        fr.readAsDataURL(bytes);\n                    }\n                }\n\n        var target = $h.getTarget('upload', params);\n        var method = $.getOpt('uploadMethod');\n\n        $.xhr.open(method, target);\n        if ($.getOpt('method') === 'octet') {\n          $.xhr.setRequestHeader('Content-Type', 'application/octet-stream');\n        }\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        var customHeaders = $.getOpt('headers');\n        if(typeof customHeaders === 'function') {\n          customHeaders = customHeaders($.fileObj, $);\n        }\n\n        $h.each(customHeaders, function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n\n                if ($.getOpt('chunkFormat') == 'blob') {\n                    $.xhr.send(data);\n                }\n      };\n      $.abort = function(){\n        // Abort and reset\n        if($.xhr) $.xhr.abort();\n        $.xhr = null;\n      };\n      $.status = function(){\n        // Returns: 'pending', 'uploading', 'success', 'error'\n        if($.pendingRetry) {\n          // if pending retry then that's effectively the same as actively uploading,\n          // there might just be a slight delay before the retry starts\n          return('uploading');\n        } else if(!$.xhr) {\n          return('pending');\n        } else if($.xhr.readyState<4) {\n          // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening\n          return('uploading');\n        } else {\n          if($.xhr.status == 200 || $.xhr.status == 201) {\n            // HTTP 200, 201 (created)\n            return('success');\n          } else if($h.contains($.getOpt('permanentErrors'), $.xhr.status) || $.retries >= $.getOpt('maxChunkRetries')) {\n            // HTTP 415/500/501, permanent error\n            return('error');\n          } else {\n            // this should never happen, but we'll reset and queue a retry\n            // a likely case for this would be 503 service unavailable\n            $.abort();\n            return('pending');\n          }\n        }\n      };\n      $.message = function(){\n        return($.xhr ? $.xhr.responseText : '');\n      };\n      $.progress = function(relative){\n        if(typeof(relative)==='undefined') relative = false;\n        var factor = (relative ? ($.endByte-$.startByte)/$.fileObjSize : 1);\n        if($.pendingRetry) return(0);\n        if(!$.xhr || !$.xhr.status) factor*=.95;\n        var s = $.status();\n        switch(s){\n        case 'success':\n        case 'error':\n          return(1*factor);\n        case 'pending':\n          return(0*factor);\n        default:\n          return($.loaded/($.endByte-$.startByte)*factor);\n        }\n      };\n      return(this);\n    }\n\n    // QUEUE\n    $.uploadNextChunk = function(){\n      var found = false;\n\n      // In some cases (such as videos) it's really handy to upload the first\n      // and last chunk of a file quickly; this let's the server check the file's\n      // metadata and determine if there's even a point in continuing.\n      if ($.getOpt('prioritizeFirstAndLastChunk')) {\n        $h.each($.files, function(file){\n          if(file.chunks.length && file.chunks[0].status()=='pending' && file.chunks[0].preprocessState === 0) {\n            file.chunks[0].send();\n            found = true;\n            return(false);\n          }\n          if(file.chunks.length>1 && file.chunks[file.chunks.length-1].status()=='pending' && file.chunks[file.chunks.length-1].preprocessState === 0) {\n            file.chunks[file.chunks.length-1].send();\n            found = true;\n            return(false);\n          }\n        });\n        if(found) return(true);\n      }\n\n      // Now, simply look for the next, best thing to upload\n      $h.each($.files, function(file){\n        if(file.isPaused()===false){\n         $h.each(file.chunks, function(chunk){\n           if(chunk.status()=='pending' && chunk.preprocessState === 0) {\n             chunk.send();\n             found = true;\n             return(false);\n           }\n          });\n        }\n        if(found) return(false);\n      });\n      if(found) return(true);\n\n      // The are no more outstanding chunks to upload, check is everything is done\n      var outstanding = false;\n      $h.each($.files, function(file){\n        if(!file.isComplete()) {\n          outstanding = true;\n          return(false);\n        }\n      });\n      if(!outstanding) {\n        // All chunks have been uploaded, complete\n        $.fire('complete');\n      }\n      return(false);\n    };\n\n\n    // PUBLIC METHODS FOR RESUMABLE.JS\n    $.assignBrowse = function(domNodes, isDirectory){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        var input;\n        if(domNode.tagName==='INPUT' && domNode.type==='file'){\n          input = domNode;\n        } else {\n          input = document.createElement('input');\n          input.setAttribute('type', 'file');\n          input.style.display = 'none';\n          domNode.addEventListener('click', function(){\n            input.style.opacity = 0;\n            input.style.display='block';\n            input.focus();\n            input.click();\n            input.style.display='none';\n          }, false);\n          domNode.appendChild(input);\n        }\n        var maxFiles = $.getOpt('maxFiles');\n        if (typeof(maxFiles)==='undefined'||maxFiles!=1){\n          input.setAttribute('multiple', 'multiple');\n        } else {\n          input.removeAttribute('multiple');\n        }\n        if(isDirectory){\n          input.setAttribute('webkitdirectory', 'webkitdirectory');\n        } else {\n          input.removeAttribute('webkitdirectory');\n        }\n        var fileTypes = $.getOpt('fileType');\n        if (typeof (fileTypes) !== 'undefined' && fileTypes.length >= 1) {\n          input.setAttribute('accept', fileTypes.map(function (e) { return '.' + e }).join(','));\n        }\n        else {\n          input.removeAttribute('accept');\n        }\n        // When new files are added, simply append them to the overall list\n        input.addEventListener('change', function(e){\n          appendFilesFromFileList(e.target.files,e);\n          var clearInput = $.getOpt('clearInput');\n          if (clearInput) {\n            e.target.value = '';\n          }\n        }, false);\n      });\n    };\n    $.assignDrop = function(domNodes){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.addEventListener('dragover', preventDefault, false);\n        domNode.addEventListener('dragenter', preventDefault, false);\n        domNode.addEventListener('drop', onDrop, false);\n      });\n    };\n    $.unAssignDrop = function(domNodes) {\n      if (typeof(domNodes.length) == 'undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.removeEventListener('dragover', preventDefault);\n        domNode.removeEventListener('dragenter', preventDefault);\n        domNode.removeEventListener('drop', onDrop);\n      });\n    };\n    $.isUploading = function(){\n      var uploading = false;\n      $h.each($.files, function(file){\n        if (file.isUploading()) {\n          uploading = true;\n          return(false);\n        }\n      });\n      return(uploading);\n    };\n    $.upload = function(){\n      // Make sure we don't start too many uploads at once\n      if($.isUploading()) return;\n      // Kick off the queue\n      $.fire('uploadStart');\n      for (var num=1; num<=$.getOpt('simultaneousUploads'); num++) {\n        $.uploadNextChunk();\n      }\n    };\n    $.pause = function(){\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        file.abort();\n      });\n      $.fire('pause');\n    };\n    $.cancel = function(){\n      $.fire('beforeCancel');\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        $.files[i].cancel();\n      }\n      $.fire('cancel');\n    };\n    $.progress = function(){\n      var totalDone = 0;\n      var totalSize = 0;\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        totalDone += file.progress()*file.size;\n        totalSize += file.size;\n      });\n      return(totalSize>0 ? totalDone/totalSize : 0);\n    };\n    $.addFile = function(file, event){\n      appendFilesFromFileList([file], event);\n    };\n    $.addFiles = function(files, event){\n      appendFilesFromFileList(files, event);\n    };\n    $.removeFile = function(file){\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        if($.files[i] === file) {\n          $.files.splice(i, 1);\n        }\n      }\n    };\n    $.getFromUniqueIdentifier = function(uniqueIdentifier){\n      var ret = false;\n      $h.each($.files, function(f){\n        if(f.uniqueIdentifier==uniqueIdentifier) ret = f;\n      });\n      return(ret);\n    };\n    $.getSize = function(){\n      var totalSize = 0;\n      $h.each($.files, function(file){\n        totalSize += file.size;\n      });\n      return(totalSize);\n    };\n    $.handleDropEvent = function (e) {\n      onDrop(e);\n    };\n    $.handleChangeEvent = function (e) {\n      appendFilesFromFileList(e.target.files, e);\n      e.target.value = '';\n    };\n    $.updateQuery = function(query){\n        $.opts.query = query;\n    };\n\n    return(this);\n  };\n\n\n  // Node.js-style export for Node and Component\n  if (true) {\n    module.exports = Resumable;\n  } else {}\n\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9ub2RlX21vZHVsZXMvcmVzdW1hYmxlanMvcmVzdW1hYmxlLmpzP2YwNTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkUsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkUsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkUsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0IsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxTQUFTO0FBQ1Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGlCQUFpQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0NBQXNDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLE1BQU0sSUFBNEI7QUFDbEM7QUFDQSxHQUFHLE1BQU0sRUFRTjs7QUFFSCxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Jlc3VtYWJsZWpzL3Jlc3VtYWJsZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4qIE1JVCBMaWNlbnNlZFxuKiBodHRwOi8vd3d3LjIzZGV2ZWxvcGVyLmNvbS9vcGVuc291cmNlXG4qIGh0dHA6Ly9naXRodWIuY29tLzIzL3Jlc3VtYWJsZS5qc1xuKiBTdGVmZmVuIFRpZWRlbWFubiBDaHJpc3RlbnNlbiwgc3RlZmZlbkAyM2NvbXBhbnkuY29tXG4qL1xuXG4oZnVuY3Rpb24oKXtcblwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBSZXN1bWFibGUgPSBmdW5jdGlvbihvcHRzKXtcbiAgICBpZiAoICEodGhpcyBpbnN0YW5jZW9mIFJlc3VtYWJsZSkgKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3VtYWJsZShvcHRzKTtcbiAgICB9XG4gICAgdGhpcy52ZXJzaW9uID0gMS4wO1xuICAgIC8vIFNVUFBPUlRFRCBCWSBCUk9XU0VSP1xuICAgIC8vIENoZWNrIGlmIHRoZXNlIGZlYXR1cmVzIGFyZSBzdXBwb3J0IGJ5IHRoZSBicm93c2VyOlxuICAgIC8vIC0gRmlsZSBvYmplY3QgdHlwZVxuICAgIC8vIC0gQmxvYiBvYmplY3QgdHlwZVxuICAgIC8vIC0gRmlsZUxpc3Qgb2JqZWN0IHR5cGVcbiAgICAvLyAtIHNsaWNpbmcgZmlsZXNcbiAgICB0aGlzLnN1cHBvcnQgPSAoXG4gICAgICAgICAgICAgICAgICAgKHR5cGVvZihGaWxlKSE9PSd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgICAgICAgKHR5cGVvZihCbG9iKSE9PSd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgICAgICAgKHR5cGVvZihGaWxlTGlzdCkhPT0ndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAgICAgICghIUJsb2IucHJvdG90eXBlLndlYmtpdFNsaWNlfHwhIUJsb2IucHJvdG90eXBlLm1velNsaWNlfHwhIUJsb2IucHJvdG90eXBlLnNsaWNlfHxmYWxzZSlcbiAgICAgICAgICAgICAgICAgICApO1xuICAgIGlmKCF0aGlzLnN1cHBvcnQpIHJldHVybihmYWxzZSk7XG5cblxuICAgIC8vIFBST1BFUlRJRVNcbiAgICB2YXIgJCA9IHRoaXM7XG4gICAgJC5maWxlcyA9IFtdO1xuICAgICQuZGVmYXVsdHMgPSB7XG4gICAgICBjaHVua1NpemU6MSoxMDI0KjEwMjQsXG4gICAgICBmb3JjZUNodW5rU2l6ZTpmYWxzZSxcbiAgICAgIHNpbXVsdGFuZW91c1VwbG9hZHM6MyxcbiAgICAgIGZpbGVQYXJhbWV0ZXJOYW1lOidmaWxlJyxcbiAgICAgIGNodW5rTnVtYmVyUGFyYW1ldGVyTmFtZTogJ3Jlc3VtYWJsZUNodW5rTnVtYmVyJyxcbiAgICAgIGNodW5rU2l6ZVBhcmFtZXRlck5hbWU6ICdyZXN1bWFibGVDaHVua1NpemUnLFxuICAgICAgY3VycmVudENodW5rU2l6ZVBhcmFtZXRlck5hbWU6ICdyZXN1bWFibGVDdXJyZW50Q2h1bmtTaXplJyxcbiAgICAgIHRvdGFsU2l6ZVBhcmFtZXRlck5hbWU6ICdyZXN1bWFibGVUb3RhbFNpemUnLFxuICAgICAgdHlwZVBhcmFtZXRlck5hbWU6ICdyZXN1bWFibGVUeXBlJyxcbiAgICAgIGlkZW50aWZpZXJQYXJhbWV0ZXJOYW1lOiAncmVzdW1hYmxlSWRlbnRpZmllcicsXG4gICAgICBmaWxlTmFtZVBhcmFtZXRlck5hbWU6ICdyZXN1bWFibGVGaWxlbmFtZScsXG4gICAgICByZWxhdGl2ZVBhdGhQYXJhbWV0ZXJOYW1lOiAncmVzdW1hYmxlUmVsYXRpdmVQYXRoJyxcbiAgICAgIHRvdGFsQ2h1bmtzUGFyYW1ldGVyTmFtZTogJ3Jlc3VtYWJsZVRvdGFsQ2h1bmtzJyxcbiAgICAgIHRocm90dGxlUHJvZ3Jlc3NDYWxsYmFja3M6IDAuNSxcbiAgICAgIHF1ZXJ5Ont9LFxuICAgICAgaGVhZGVyczp7fSxcbiAgICAgIHByZXByb2Nlc3M6bnVsbCxcbiAgICAgIG1ldGhvZDonbXVsdGlwYXJ0JyxcbiAgICAgIHVwbG9hZE1ldGhvZDogJ1BPU1QnLFxuICAgICAgdGVzdE1ldGhvZDogJ0dFVCcsXG4gICAgICBwcmlvcml0aXplRmlyc3RBbmRMYXN0Q2h1bms6ZmFsc2UsXG4gICAgICB0YXJnZXQ6Jy8nLFxuICAgICAgdGVzdFRhcmdldDogbnVsbCxcbiAgICAgIHBhcmFtZXRlck5hbWVzcGFjZTonJyxcbiAgICAgIHRlc3RDaHVua3M6dHJ1ZSxcbiAgICAgIGdlbmVyYXRlVW5pcXVlSWRlbnRpZmllcjpudWxsLFxuICAgICAgZ2V0VGFyZ2V0Om51bGwsXG4gICAgICBtYXhDaHVua1JldHJpZXM6MTAwLFxuICAgICAgY2h1bmtSZXRyeUludGVydmFsOnVuZGVmaW5lZCxcbiAgICAgIHBlcm1hbmVudEVycm9yczpbNDAwLCA0MDQsIDQxNSwgNTAwLCA1MDFdLFxuICAgICAgbWF4RmlsZXM6dW5kZWZpbmVkLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOmZhbHNlLFxuICAgICAgeGhyVGltZW91dDowLFxuICAgICAgY2xlYXJJbnB1dDp0cnVlLFxuICAgICAgY2h1bmtGb3JtYXQ6J2Jsb2InLFxuICAgICAgc2V0Q2h1bmtUeXBlRnJvbUZpbGU6ZmFsc2UsXG4gICAgICBtYXhGaWxlc0Vycm9yQ2FsbGJhY2s6ZnVuY3Rpb24gKGZpbGVzLCBlcnJvckNvdW50KSB7XG4gICAgICAgIHZhciBtYXhGaWxlcyA9ICQuZ2V0T3B0KCdtYXhGaWxlcycpO1xuICAgICAgICBhbGVydCgnUGxlYXNlIHVwbG9hZCBubyBtb3JlIHRoYW4gJyArIG1heEZpbGVzICsgJyBmaWxlJyArIChtYXhGaWxlcyA9PT0gMSA/ICcnIDogJ3MnKSArICcgYXQgYSB0aW1lLicpO1xuICAgICAgfSxcbiAgICAgIG1pbkZpbGVTaXplOjEsXG4gICAgICBtaW5GaWxlU2l6ZUVycm9yQ2FsbGJhY2s6ZnVuY3Rpb24oZmlsZSwgZXJyb3JDb3VudCkge1xuICAgICAgICBhbGVydChmaWxlLmZpbGVOYW1lfHxmaWxlLm5hbWUgKycgaXMgdG9vIHNtYWxsLCBwbGVhc2UgdXBsb2FkIGZpbGVzIGxhcmdlciB0aGFuICcgKyAkaC5mb3JtYXRTaXplKCQuZ2V0T3B0KCdtaW5GaWxlU2l6ZScpKSArICcuJyk7XG4gICAgICB9LFxuICAgICAgbWF4RmlsZVNpemU6dW5kZWZpbmVkLFxuICAgICAgbWF4RmlsZVNpemVFcnJvckNhbGxiYWNrOmZ1bmN0aW9uKGZpbGUsIGVycm9yQ291bnQpIHtcbiAgICAgICAgYWxlcnQoZmlsZS5maWxlTmFtZXx8ZmlsZS5uYW1lICsnIGlzIHRvbyBsYXJnZSwgcGxlYXNlIHVwbG9hZCBmaWxlcyBsZXNzIHRoYW4gJyArICRoLmZvcm1hdFNpemUoJC5nZXRPcHQoJ21heEZpbGVTaXplJykpICsgJy4nKTtcbiAgICAgIH0sXG4gICAgICBmaWxlVHlwZTogW10sXG4gICAgICBmaWxlVHlwZUVycm9yQ2FsbGJhY2s6IGZ1bmN0aW9uKGZpbGUsIGVycm9yQ291bnQpIHtcbiAgICAgICAgYWxlcnQoZmlsZS5maWxlTmFtZXx8ZmlsZS5uYW1lICsnIGhhcyB0eXBlIG5vdCBhbGxvd2VkLCBwbGVhc2UgdXBsb2FkIGZpbGVzIG9mIHR5cGUgJyArICQuZ2V0T3B0KCdmaWxlVHlwZScpICsgJy4nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgICQub3B0cyA9IG9wdHN8fHt9O1xuICAgICQuZ2V0T3B0ID0gZnVuY3Rpb24obykge1xuICAgICAgdmFyICRvcHQgPSB0aGlzO1xuICAgICAgLy8gR2V0IG11bHRpcGxlIG9wdGlvbiBpZiBwYXNzZWQgYW4gYXJyYXlcbiAgICAgIGlmKG8gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAkaC5lYWNoKG8sIGZ1bmN0aW9uKG9wdGlvbil7XG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25dID0gJG9wdC5nZXRPcHQob3B0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiBhIHNpbXBsZSBvcHRpb25cbiAgICAgIGlmICgkb3B0IGluc3RhbmNlb2YgUmVzdW1hYmxlQ2h1bmspIHtcbiAgICAgICAgaWYgKHR5cGVvZiAkb3B0Lm9wdHNbb10gIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiAkb3B0Lm9wdHNbb107IH1cbiAgICAgICAgZWxzZSB7ICRvcHQgPSAkb3B0LmZpbGVPYmo7IH1cbiAgICAgIH1cbiAgICAgIGlmICgkb3B0IGluc3RhbmNlb2YgUmVzdW1hYmxlRmlsZSkge1xuICAgICAgICBpZiAodHlwZW9mICRvcHQub3B0c1tvXSAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuICRvcHQub3B0c1tvXTsgfVxuICAgICAgICBlbHNlIHsgJG9wdCA9ICRvcHQucmVzdW1hYmxlT2JqOyB9XG4gICAgICB9XG4gICAgICBpZiAoJG9wdCBpbnN0YW5jZW9mIFJlc3VtYWJsZSkge1xuICAgICAgICBpZiAodHlwZW9mICRvcHQub3B0c1tvXSAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuICRvcHQub3B0c1tvXTsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuICRvcHQuZGVmYXVsdHNbb107IH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRVZFTlRTXG4gICAgLy8gY2F0Y2hBbGwoZXZlbnQsIC4uLilcbiAgICAvLyBmaWxlU3VjY2VzcyhmaWxlKSwgZmlsZVByb2dyZXNzKGZpbGUpLCBmaWxlQWRkZWQoZmlsZSwgZXZlbnQpLCBmaWxlc0FkZGVkKGZpbGVzLCBmaWxlc1NraXBwZWQpLCBmaWxlUmV0cnkoZmlsZSksXG4gICAgLy8gZmlsZUVycm9yKGZpbGUsIG1lc3NhZ2UpLCBjb21wbGV0ZSgpLCBwcm9ncmVzcygpLCBlcnJvcihtZXNzYWdlLCBmaWxlKSwgcGF1c2UoKVxuICAgICQuZXZlbnRzID0gW107XG4gICAgJC5vbiA9IGZ1bmN0aW9uKGV2ZW50LGNhbGxiYWNrKXtcbiAgICAgICQuZXZlbnRzLnB1c2goZXZlbnQudG9Mb3dlckNhc2UoKSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgJC5maXJlID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIGBhcmd1bWVudHNgIGlzIGFuIG9iamVjdCwgbm90IGFycmF5LCBpbiBGRiwgc286XG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAvLyBGaW5kIGV2ZW50IGxpc3RlbmVycywgYW5kIHN1cHBvcnQgcHNldWRvLWV2ZW50IGBjYXRjaEFsbGBcbiAgICAgIHZhciBldmVudCA9IGFyZ3NbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTw9JC5ldmVudHMubGVuZ3RoOyBpKz0yKSB7XG4gICAgICAgIGlmKCQuZXZlbnRzW2ldPT1ldmVudCkgJC5ldmVudHNbaSsxXS5hcHBseSgkLGFyZ3Muc2xpY2UoMSkpO1xuICAgICAgICBpZigkLmV2ZW50c1tpXT09J2NhdGNoYWxsJykgJC5ldmVudHNbaSsxXS5hcHBseShudWxsLGFyZ3MpO1xuICAgICAgfVxuICAgICAgaWYoZXZlbnQ9PSdmaWxlZXJyb3InKSAkLmZpcmUoJ2Vycm9yJywgYXJnc1syXSwgYXJnc1sxXSk7XG4gICAgICBpZihldmVudD09J2ZpbGVwcm9ncmVzcycpICQuZmlyZSgncHJvZ3Jlc3MnKTtcbiAgICB9O1xuXG5cbiAgICAvLyBJTlRFUk5BTCBIRUxQRVIgTUVUSE9EUyAoaGFuZHksIGJ1dCB1bHRpbWF0ZWx5IG5vdCBwYXJ0IG9mIHVwbG9hZGluZylcbiAgICB2YXIgJGggPSB7XG4gICAgICBzdG9wRXZlbnQ6IGZ1bmN0aW9uKGUpe1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LFxuICAgICAgZWFjaDogZnVuY3Rpb24obyxjYWxsYmFjayl7XG4gICAgICAgIGlmKHR5cGVvZihvLmxlbmd0aCkhPT0ndW5kZWZpbmVkJykge1xuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBBcnJheSBvciBGaWxlTGlzdFxuICAgICAgICAgICAgaWYoY2FsbGJhY2sob1tpXSk9PT1mYWxzZSkgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGkgaW4gbykge1xuICAgICAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgICAgICBpZihjYWxsYmFjayhpLG9baV0pPT09ZmFsc2UpIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXI6ZnVuY3Rpb24oZmlsZSwgZXZlbnQpe1xuICAgICAgICB2YXIgY3VzdG9tID0gJC5nZXRPcHQoJ2dlbmVyYXRlVW5pcXVlSWRlbnRpZmllcicpO1xuICAgICAgICBpZih0eXBlb2YgY3VzdG9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGN1c3RvbShmaWxlLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbGF0aXZlUGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRofHxmaWxlLmZpbGVOYW1lfHxmaWxlLm5hbWU7IC8vIFNvbWUgY29uZnVzaW9uIGluIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBGaXJlZm94XG4gICAgICAgIHZhciBzaXplID0gZmlsZS5zaXplO1xuICAgICAgICByZXR1cm4oc2l6ZSArICctJyArIHJlbGF0aXZlUGF0aC5yZXBsYWNlKC9bXjAtOWEtekEtWl8tXS9pbWcsICcnKSk7XG4gICAgICB9LFxuICAgICAgY29udGFpbnM6ZnVuY3Rpb24oYXJyYXksdGVzdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgJGguZWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gdGVzdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZm9ybWF0U2l6ZTpmdW5jdGlvbihzaXplKXtcbiAgICAgICAgaWYoc2l6ZTwxMDI0KSB7XG4gICAgICAgICAgcmV0dXJuIHNpemUgKyAnIGJ5dGVzJztcbiAgICAgICAgfSBlbHNlIGlmKHNpemU8MTAyNCoxMDI0KSB7XG4gICAgICAgICAgcmV0dXJuIChzaXplLzEwMjQuMCkudG9GaXhlZCgwKSArICcgS0InO1xuICAgICAgICB9IGVsc2UgaWYoc2l6ZTwxMDI0KjEwMjQqMTAyNCkge1xuICAgICAgICAgIHJldHVybiAoc2l6ZS8xMDI0LjAvMTAyNC4wKS50b0ZpeGVkKDEpICsgJyBNQic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChzaXplLzEwMjQuMC8xMDI0LjAvMTAyNC4wKS50b0ZpeGVkKDEpICsgJyBHQic7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRUYXJnZXQ6ZnVuY3Rpb24ocmVxdWVzdCwgcGFyYW1zKXtcbiAgICAgICAgdmFyIHRhcmdldCA9ICQuZ2V0T3B0KCd0YXJnZXQnKTtcblxuICAgICAgICBpZiAocmVxdWVzdCA9PT0gJ3Rlc3QnICYmICQuZ2V0T3B0KCd0ZXN0VGFyZ2V0JykpIHtcbiAgICAgICAgICB0YXJnZXQgPSAkLmdldE9wdCgndGVzdFRhcmdldCcpID09PSAnLycgPyAkLmdldE9wdCgndGFyZ2V0JykgOiAkLmdldE9wdCgndGVzdFRhcmdldCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0KHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VwYXJhdG9yID0gdGFyZ2V0LmluZGV4T2YoJz8nKSA8IDAgPyAnPycgOiAnJic7XG4gICAgICAgIHZhciBqb2luZWRQYXJhbXMgPSBwYXJhbXMuam9pbignJicpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQgKyBzZXBhcmF0b3IgKyBqb2luZWRQYXJhbXM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbkRyb3AgPSBmdW5jdGlvbihldmVudCl7XG4gICAgICAkaC5zdG9wRXZlbnQoZXZlbnQpO1xuXG4gICAgICAvL2hhbmRsZSBkcm9wcGVkIHRoaW5ncyBhcyBpdGVtcyBpZiB3ZSBjYW4gKHRoaXMgbGV0cyB1cyBkZWFsIHdpdGggZm9sZGVycyBuaWNlciBpbiBzb21lIGNhc2VzKVxuICAgICAgaWYgKGV2ZW50LmRhdGFUcmFuc2ZlciAmJiBldmVudC5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgICAgbG9hZEZpbGVzKGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcywgZXZlbnQpO1xuICAgICAgfVxuICAgICAgLy9lbHNlIGhhbmRsZSB0aGVtIGFzIGZpbGVzXG4gICAgICBlbHNlIGlmIChldmVudC5kYXRhVHJhbnNmZXIgJiYgZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKSB7XG4gICAgICAgIGxvYWRGaWxlcyhldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcHJvY2Vzc2VzIGEgc2luZ2xlIHVwbG9hZCBpdGVtIChmaWxlIG9yIGRpcmVjdG9yeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBpdGVtIHRvIHVwbG9hZCwgbWF5IGJlIGZpbGUgb3IgZGlyZWN0b3J5IGVudHJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggY3VycmVudCBmaWxlIHBhdGhcbiAgICAgKiBAcGFyYW0ge0ZpbGVbXX0gaXRlbXMgbGlzdCBvZiBmaWxlcyB0byBhcHBlbmQgbmV3IGl0ZW1zIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgY2FsbGJhY2sgaW52b2tlZCB3aGVuIGl0ZW0gaXMgcHJvY2Vzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0l0ZW0oaXRlbSwgcGF0aCwgaXRlbXMsIGNiKSB7XG4gICAgICB2YXIgZW50cnk7XG4gICAgICBpZihpdGVtLmlzRmlsZSl7XG4gICAgICAgIC8vIGZpbGUgcHJvdmlkZWRcbiAgICAgICAgcmV0dXJuIGl0ZW0uZmlsZShmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgICBmaWxlLnJlbGF0aXZlUGF0aCA9IHBhdGggKyBmaWxlLm5hbWU7XG4gICAgICAgICAgaXRlbXMucHVzaChmaWxlKTtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9KTtcbiAgICAgIH1lbHNlIGlmKGl0ZW0uaXNEaXJlY3Rvcnkpe1xuICAgICAgICAvLyBpdGVtIGlzIGFscmVhZHkgYSBkaXJlY3RvcnkgZW50cnksIGp1c3QgYXNzaWduXG4gICAgICAgIGVudHJ5ID0gaXRlbTtcbiAgICAgIH1lbHNlIGlmKGl0ZW0gaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgICBpZignZnVuY3Rpb24nID09PSB0eXBlb2YgaXRlbS53ZWJraXRHZXRBc0VudHJ5KXtcbiAgICAgICAgLy8gZ2V0IGVudHJ5IGZyb20gZmlsZSBvYmplY3RcbiAgICAgICAgZW50cnkgPSBpdGVtLndlYmtpdEdldEFzRW50cnkoKTtcbiAgICAgIH1cbiAgICAgIGlmKGVudHJ5ICYmIGVudHJ5LmlzRGlyZWN0b3J5KXtcbiAgICAgICAgLy8gZGlyZWN0b3J5IHByb3ZpZGVkLCBwcm9jZXNzIGl0XG4gICAgICAgIHJldHVybiBwcm9jZXNzRGlyZWN0b3J5KGVudHJ5LCBwYXRoICsgZW50cnkubmFtZSArICcvJywgaXRlbXMsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiBpdGVtLmdldEFzRmlsZSl7XG4gICAgICAgIC8vIGl0ZW0gcmVwcmVzZW50cyBhIEZpbGUgb2JqZWN0LCBjb252ZXJ0IGl0XG4gICAgICAgIGl0ZW0gPSBpdGVtLmdldEFzRmlsZSgpO1xuICAgICAgICBpZihpdGVtIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgIGl0ZW0ucmVsYXRpdmVQYXRoID0gcGF0aCArIGl0ZW0ubmFtZTtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYigpOyAvLyBpbmRpY2F0ZSBwcm9jZXNzaW5nIGlzIGRvbmVcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIGNwcy1zdHlsZSBsaXN0IGl0ZXJhdGlvbi5cbiAgICAgKiBpbnZva2VzIGFsbCBmdW5jdGlvbnMgaW4gbGlzdCBhbmQgd2FpdHMgZm9yIHRoZWlyIGNhbGxiYWNrIHRvIGJlXG4gICAgICogdHJpZ2dlcmVkLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9uW119ICAgaXRlbXMgbGlzdCBvZiBmdW5jdGlvbnMgZXhwZWN0aW5nIGNhbGxiYWNrIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYiAgICBjYWxsYmFjayB0byB0cmlnZ2VyIGFmdGVyIHRoZSBsYXN0IGNhbGxiYWNrIGhhcyBiZWVuIGludm9rZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzQ2FsbGJhY2tzKGl0ZW1zLCBjYil7XG4gICAgICBpZighaXRlbXMgfHwgaXRlbXMubGVuZ3RoID09PSAwKXtcbiAgICAgICAgLy8gZW1wdHkgb3Igbm8gbGlzdCwgaW52b2tlIGNhbGxiYWNrXG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfVxuICAgICAgLy8gaW52b2tlIGN1cnJlbnQgZnVuY3Rpb24sIHBhc3MgdGhlIG5leHQgcGFydCBhcyBjb250aW51YXRpb25cbiAgICAgIGl0ZW1zWzBdKGZ1bmN0aW9uKCl7XG4gICAgICAgIHByb2Nlc3NDYWxsYmFja3MoaXRlbXMuc2xpY2UoMSksIGNiKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGRpcmVjdG9yeSBhbmQgY29sbGVjdCBmaWxlcyB0byB1cGxvYWRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgZGlyZWN0b3J5IGRpcmVjdG9yeSB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgIHBhdGggICAgICBjdXJyZW50IHBhdGhcbiAgICAgKiBAcGFyYW0gIHtGaWxlW119ICAgaXRlbXMgICAgIHRhcmdldCBsaXN0IG9mIGl0ZW1zXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiICAgICAgICBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHRyYXZlcnNpbmcgZGlyZWN0b3J5XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RpcmVjdG9yeSAoZGlyZWN0b3J5LCBwYXRoLCBpdGVtcywgY2IpIHtcbiAgICAgIHZhciBkaXJSZWFkZXIgPSBkaXJlY3RvcnkuY3JlYXRlUmVhZGVyKCk7XG4gICAgICBkaXJSZWFkZXIucmVhZEVudHJpZXMoZnVuY3Rpb24oZW50cmllcyl7XG4gICAgICAgIGlmKCFlbnRyaWVzLmxlbmd0aCl7XG4gICAgICAgICAgLy8gZW1wdHkgZGlyZWN0b3J5LCBza2lwXG4gICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvY2VzcyBhbGwgY29udmVyc2lvbiBjYWxsYmFja3MsIGZpbmFsbHkgaW52b2tlIG93biBvbmVcbiAgICAgICAgcHJvY2Vzc0NhbGxiYWNrcyhcbiAgICAgICAgICBlbnRyaWVzLm1hcChmdW5jdGlvbihlbnRyeSl7XG4gICAgICAgICAgICAvLyBiaW5kIGFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgY2FsbGJhY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzSXRlbS5iaW5kKG51bGwsIGVudHJ5LCBwYXRoLCBpdGVtcyk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY2JcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb2Nlc3MgaXRlbXMgdG8gZXh0cmFjdCBmaWxlcyB0byBiZSB1cGxvYWRlZFxuICAgICAqIEBwYXJhbSAge0ZpbGVbXX0gaXRlbXMgaXRlbXMgdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSAge0V2ZW50fSBldmVudCBldmVudCB0aGF0IGxlZCB0byB1cGxvYWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRmlsZXMoaXRlbXMsIGV2ZW50KSB7XG4gICAgICBpZighaXRlbXMubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuOyAvLyBub3RoaW5nIHRvIGRvXG4gICAgICB9XG4gICAgICAkLmZpcmUoJ2JlZm9yZUFkZCcpO1xuICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgICBwcm9jZXNzQ2FsbGJhY2tzKFxuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChpdGVtcywgZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgICAgICAvLyBiaW5kIGFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgY2FsbGJhY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzSXRlbS5iaW5kKG51bGwsIGl0ZW0sIFwiXCIsIGZpbGVzKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYoZmlsZXMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgLy8gYXQgbGVhc3Qgb25lIGZpbGUgZm91bmRcbiAgICAgICAgICAgICAgYXBwZW5kRmlsZXNGcm9tRmlsZUxpc3QoZmlsZXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgYXBwZW5kRmlsZXNGcm9tRmlsZUxpc3QgPSBmdW5jdGlvbihmaWxlTGlzdCwgZXZlbnQpe1xuICAgICAgLy8gY2hlY2sgZm9yIHVwbG9hZGluZyB0b28gbWFueSBmaWxlc1xuICAgICAgdmFyIGVycm9yQ291bnQgPSAwO1xuICAgICAgdmFyIG8gPSAkLmdldE9wdChbJ21heEZpbGVzJywgJ21pbkZpbGVTaXplJywgJ21heEZpbGVTaXplJywgJ21heEZpbGVzRXJyb3JDYWxsYmFjaycsICdtaW5GaWxlU2l6ZUVycm9yQ2FsbGJhY2snLCAnbWF4RmlsZVNpemVFcnJvckNhbGxiYWNrJywgJ2ZpbGVUeXBlJywgJ2ZpbGVUeXBlRXJyb3JDYWxsYmFjayddKTtcbiAgICAgIGlmICh0eXBlb2Yoby5tYXhGaWxlcykhPT0ndW5kZWZpbmVkJyAmJiBvLm1heEZpbGVzPChmaWxlTGlzdC5sZW5ndGgrJC5maWxlcy5sZW5ndGgpKSB7XG4gICAgICAgIC8vIGlmIHNpbmdsZS1maWxlIHVwbG9hZCwgZmlsZSBpcyBhbHJlYWR5IGFkZGVkLCBhbmQgdHJ5aW5nIHRvIGFkZCAxIG5ldyBmaWxlLCBzaW1wbHkgcmVwbGFjZSB0aGUgYWxyZWFkeS1hZGRlZCBmaWxlXG4gICAgICAgIGlmIChvLm1heEZpbGVzPT09MSAmJiAkLmZpbGVzLmxlbmd0aD09PTEgJiYgZmlsZUxpc3QubGVuZ3RoPT09MSkge1xuICAgICAgICAgICQucmVtb3ZlRmlsZSgkLmZpbGVzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvLm1heEZpbGVzRXJyb3JDYWxsYmFjayhmaWxlTGlzdCwgZXJyb3JDb3VudCsrKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBmaWxlcyA9IFtdLCBmaWxlc1NraXBwZWQgPSBbXSwgcmVtYWluaW5nID0gZmlsZUxpc3QubGVuZ3RoO1xuICAgICAgdmFyIGRlY3JlYXNlUmVhbWluaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIS0tcmVtYWluaW5nKXtcbiAgICAgICAgICAvLyBhbGwgZmlsZXMgcHJvY2Vzc2VkLCB0cmlnZ2VyIGV2ZW50XG4gICAgICAgICAgaWYoIWZpbGVzLmxlbmd0aCAmJiAhZmlsZXNTa2lwcGVkLmxlbmd0aCl7XG4gICAgICAgICAgICAvLyBubyBzdWNjZWVkZWQgZmlsZXMsIGp1c3Qgc2tpcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgJC5maXJlKCdmaWxlc0FkZGVkJywgZmlsZXMsIGZpbGVzU2tpcHBlZCk7XG4gICAgICAgICAgfSwwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgICRoLmVhY2goZmlsZUxpc3QsIGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgIGlmKG8uZmlsZVR5cGUubGVuZ3RoID4gMCl7XG4gICAgICAgICAgdmFyIGZpbGVUeXBlRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IodmFyIGluZGV4IGluIG8uZmlsZVR5cGUpe1xuICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9ICcuJyArIG8uZmlsZVR5cGVbaW5kZXhdO1xuXHRcdFx0aWYoZmlsZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpLCBmaWxlTmFtZS5sZW5ndGggLSBleHRlbnNpb24ubGVuZ3RoKSAhPT0gLTEpe1xuICAgICAgICAgICAgICBmaWxlVHlwZUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZmlsZVR5cGVGb3VuZCkge1xuICAgICAgICAgICAgby5maWxlVHlwZUVycm9yQ2FsbGJhY2soZmlsZSwgZXJyb3JDb3VudCsrKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKG8ubWluRmlsZVNpemUpIT09J3VuZGVmaW5lZCcgJiYgZmlsZS5zaXplPG8ubWluRmlsZVNpemUpIHtcbiAgICAgICAgICBvLm1pbkZpbGVTaXplRXJyb3JDYWxsYmFjayhmaWxlLCBlcnJvckNvdW50KyspO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKG8ubWF4RmlsZVNpemUpIT09J3VuZGVmaW5lZCcgJiYgZmlsZS5zaXplPm8ubWF4RmlsZVNpemUpIHtcbiAgICAgICAgICBvLm1heEZpbGVTaXplRXJyb3JDYWxsYmFjayhmaWxlLCBlcnJvckNvdW50KyspO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEZpbGUodW5pcXVlSWRlbnRpZmllcil7XG4gICAgICAgICAgaWYgKCEkLmdldEZyb21VbmlxdWVJZGVudGlmaWVyKHVuaXF1ZUlkZW50aWZpZXIpKSB7KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBmaWxlLnVuaXF1ZUlkZW50aWZpZXIgPSB1bmlxdWVJZGVudGlmaWVyO1xuICAgICAgICAgICAgdmFyIGYgPSBuZXcgUmVzdW1hYmxlRmlsZSgkLCBmaWxlLCB1bmlxdWVJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICQuZmlsZXMucHVzaChmKTtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goZik7XG4gICAgICAgICAgICBmLmNvbnRhaW5lciA9ICh0eXBlb2YgZXZlbnQgIT0gJ3VuZGVmaW5lZCcgPyBldmVudC5zcmNFbGVtZW50IDogbnVsbCk7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAkLmZpcmUoJ2ZpbGVBZGRlZCcsIGYsIGV2ZW50KVxuICAgICAgICAgICAgfSwwKTtcbiAgICAgICAgICB9KSgpfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGVzU2tpcHBlZC5wdXNoKGZpbGUpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZGVjcmVhc2VSZWFtaW5pbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaXJlY3RvcmllcyBoYXZlIHNpemUgPT0gMFxuICAgICAgICB2YXIgdW5pcXVlSWRlbnRpZmllciA9ICRoLmdlbmVyYXRlVW5pcXVlSWRlbnRpZmllcihmaWxlLCBldmVudCk7XG4gICAgICAgIGlmKHVuaXF1ZUlkZW50aWZpZXIgJiYgdHlwZW9mIHVuaXF1ZUlkZW50aWZpZXIudGhlbiA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgLy8gUHJvbWlzZSBvciBQcm9taXNlLWxpa2Ugb2JqZWN0IHByb3ZpZGVkIGFzIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgICAgICAgdW5pcXVlSWRlbnRpZmllclxuICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24odW5pcXVlSWRlbnRpZmllcil7XG4gICAgICAgICAgICAgIC8vIHVuaXF1ZSBpZGVudGlmaWVyIGdlbmVyYXRpb24gc3VjY2VlZGVkXG4gICAgICAgICAgICAgIGFkZEZpbGUodW5pcXVlSWRlbnRpZmllcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAvLyB1bmlxdWUgaWRlbnRpZmllciBnZW5lcmF0aW9uIGZhaWxlZFxuICAgICAgICAgICAgICAvLyBza2lwIGZ1cnRoZXIgcHJvY2Vzc2luZywgb25seSBkZWNyZWFzZSBmaWxlIGNvdW50XG4gICAgICAgICAgICAgIGRlY3JlYXNlUmVhbWluaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy8gbm9uLVByb21pc2UgcHJvdmlkZWQgYXMgdW5pcXVlIGlkZW50aWZpZXIsIHByb2Nlc3Mgc3luY2hyb25vdXNseVxuICAgICAgICAgIGFkZEZpbGUodW5pcXVlSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBJTlRFUk5BTCBPQkpFQ1QgVFlQRVNcbiAgICBmdW5jdGlvbiBSZXN1bWFibGVGaWxlKHJlc3VtYWJsZU9iaiwgZmlsZSwgdW5pcXVlSWRlbnRpZmllcil7XG4gICAgICB2YXIgJCA9IHRoaXM7XG4gICAgICAkLm9wdHMgPSB7fTtcbiAgICAgICQuZ2V0T3B0ID0gcmVzdW1hYmxlT2JqLmdldE9wdDtcbiAgICAgICQuX3ByZXZQcm9ncmVzcyA9IDA7XG4gICAgICAkLnJlc3VtYWJsZU9iaiA9IHJlc3VtYWJsZU9iajtcbiAgICAgICQuZmlsZSA9IGZpbGU7XG4gICAgICAkLmZpbGVOYW1lID0gZmlsZS5maWxlTmFtZXx8ZmlsZS5uYW1lOyAvLyBTb21lIGNvbmZ1c2lvbiBpbiBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgRmlyZWZveFxuICAgICAgJC5zaXplID0gZmlsZS5zaXplO1xuICAgICAgJC5yZWxhdGl2ZVBhdGggPSBmaWxlLnJlbGF0aXZlUGF0aCB8fCBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aCB8fCAkLmZpbGVOYW1lO1xuICAgICAgJC51bmlxdWVJZGVudGlmaWVyID0gdW5pcXVlSWRlbnRpZmllcjtcbiAgICAgICQuX3BhdXNlID0gZmFsc2U7XG4gICAgICAkLmNvbnRhaW5lciA9ICcnO1xuICAgICAgdmFyIF9lcnJvciA9IHVuaXF1ZUlkZW50aWZpZXIgIT09IHVuZGVmaW5lZDtcblxuICAgICAgLy8gQ2FsbGJhY2sgd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoaW4gdGhlIGNodW5rXG4gICAgICB2YXIgY2h1bmtFdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBtZXNzYWdlKXtcbiAgICAgICAgLy8gZXZlbnQgY2FuIGJlICdwcm9ncmVzcycsICdzdWNjZXNzJywgJ2Vycm9yJyBvciAncmV0cnknXG4gICAgICAgIHN3aXRjaChldmVudCl7XG4gICAgICAgIGNhc2UgJ3Byb2dyZXNzJzpcbiAgICAgICAgICAkLnJlc3VtYWJsZU9iai5maXJlKCdmaWxlUHJvZ3Jlc3MnLCAkLCBtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICQuYWJvcnQoKTtcbiAgICAgICAgICBfZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICQuY2h1bmtzID0gW107XG4gICAgICAgICAgJC5yZXN1bWFibGVPYmouZmlyZSgnZmlsZUVycm9yJywgJCwgbWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICAgIGlmKF9lcnJvcikgcmV0dXJuO1xuICAgICAgICAgICQucmVzdW1hYmxlT2JqLmZpcmUoJ2ZpbGVQcm9ncmVzcycsICQpOyAvLyBpdCdzIGF0IGxlYXN0IHByb2dyZXNzXG4gICAgICAgICAgaWYoJC5pc0NvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgICQucmVzdW1hYmxlT2JqLmZpcmUoJ2ZpbGVTdWNjZXNzJywgJCwgbWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZXRyeSc6XG4gICAgICAgICAgJC5yZXN1bWFibGVPYmouZmlyZSgnZmlsZVJldHJ5JywgJCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIE1haW4gY29kZSB0byBzZXQgdXAgYSBmaWxlIG9iamVjdCB3aXRoIGNodW5rcyxcbiAgICAgIC8vIHBhY2thZ2VkIHRvIGJlIGFibGUgdG8gaGFuZGxlIHJldHJpZXMgaWYgbmVlZGVkLlxuICAgICAgJC5jaHVua3MgPSBbXTtcbiAgICAgICQuYWJvcnQgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBTdG9wIGN1cnJlbnQgdXBsb2Fkc1xuICAgICAgICB2YXIgYWJvcnRDb3VudCA9IDA7XG4gICAgICAgICRoLmVhY2goJC5jaHVua3MsIGZ1bmN0aW9uKGMpe1xuICAgICAgICAgIGlmKGMuc3RhdHVzKCk9PSd1cGxvYWRpbmcnKSB7XG4gICAgICAgICAgICBjLmFib3J0KCk7XG4gICAgICAgICAgICBhYm9ydENvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYoYWJvcnRDb3VudD4wKSAkLnJlc3VtYWJsZU9iai5maXJlKCdmaWxlUHJvZ3Jlc3MnLCAkKTtcbiAgICAgIH07XG4gICAgICAkLmNhbmNlbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFJlc2V0IHRoaXMgZmlsZSB0byBiZSB2b2lkXG4gICAgICAgIHZhciBfY2h1bmtzID0gJC5jaHVua3M7XG4gICAgICAgICQuY2h1bmtzID0gW107XG4gICAgICAgIC8vIFN0b3AgY3VycmVudCB1cGxvYWRzXG4gICAgICAgICRoLmVhY2goX2NodW5rcywgZnVuY3Rpb24oYyl7XG4gICAgICAgICAgaWYoYy5zdGF0dXMoKT09J3VwbG9hZGluZycpICB7XG4gICAgICAgICAgICBjLmFib3J0KCk7XG4gICAgICAgICAgICAkLnJlc3VtYWJsZU9iai51cGxvYWROZXh0Q2h1bmsoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkLnJlc3VtYWJsZU9iai5yZW1vdmVGaWxlKCQpO1xuICAgICAgICAkLnJlc3VtYWJsZU9iai5maXJlKCdmaWxlUHJvZ3Jlc3MnLCAkKTtcbiAgICAgIH07XG4gICAgICAkLnJldHJ5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgJC5ib290c3RyYXAoKTtcbiAgICAgICAgdmFyIGZpcmVkUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgJC5yZXN1bWFibGVPYmoub24oJ2NodW5raW5nQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuICAgICAgICAgIGlmKCFmaXJlZFJldHJ5KSAkLnJlc3VtYWJsZU9iai51cGxvYWQoKTtcbiAgICAgICAgICBmaXJlZFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgJC5ib290c3RyYXAgPSBmdW5jdGlvbigpe1xuICAgICAgICAkLmFib3J0KCk7XG4gICAgICAgIF9lcnJvciA9IGZhbHNlO1xuICAgICAgICAvLyBSZWJ1aWxkIHN0YWNrIG9mIGNodW5rcyBmcm9tIGZpbGVcbiAgICAgICAgJC5jaHVua3MgPSBbXTtcbiAgICAgICAgJC5fcHJldlByb2dyZXNzID0gMDtcbiAgICAgICAgdmFyIHJvdW5kID0gJC5nZXRPcHQoJ2ZvcmNlQ2h1bmtTaXplJykgPyBNYXRoLmNlaWwgOiBNYXRoLmZsb29yO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gTWF0aC5tYXgocm91bmQoJC5maWxlLnNpemUvJC5nZXRPcHQoJ2NodW5rU2l6ZScpKSwxKTtcbiAgICAgICAgZm9yICh2YXIgb2Zmc2V0PTA7IG9mZnNldDxtYXhPZmZzZXQ7IG9mZnNldCsrKSB7KGZ1bmN0aW9uKG9mZnNldCl7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICQuY2h1bmtzLnB1c2gobmV3IFJlc3VtYWJsZUNodW5rKCQucmVzdW1hYmxlT2JqLCAkLCBvZmZzZXQsIGNodW5rRXZlbnQpKTtcbiAgICAgICAgICAgICAgICAkLnJlc3VtYWJsZU9iai5maXJlKCdjaHVua2luZ1Byb2dyZXNzJywkLG9mZnNldC9tYXhPZmZzZXQpO1xuICAgICAgICAgICAgfSwwKTtcbiAgICAgICAgfSkob2Zmc2V0KX1cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQucmVzdW1hYmxlT2JqLmZpcmUoJ2NodW5raW5nQ29tcGxldGUnLCQpO1xuICAgICAgICB9LDApO1xuICAgICAgfTtcbiAgICAgICQucHJvZ3Jlc3MgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZihfZXJyb3IpIHJldHVybigxKTtcbiAgICAgICAgLy8gU3VtIHVwIHByb2dyZXNzIGFjcm9zcyBldmVyeXRoaW5nXG4gICAgICAgIHZhciByZXQgPSAwO1xuICAgICAgICB2YXIgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgJGguZWFjaCgkLmNodW5rcywgZnVuY3Rpb24oYyl7XG4gICAgICAgICAgaWYoYy5zdGF0dXMoKT09J2Vycm9yJykgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHJldCArPSBjLnByb2dyZXNzKHRydWUpOyAvLyBnZXQgY2h1bmsgcHJvZ3Jlc3MgcmVsYXRpdmUgdG8gZW50aXJlIGZpbGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldCA9IChlcnJvciA/IDEgOiAocmV0PjAuOTk5OTkgPyAxIDogcmV0KSk7XG4gICAgICAgIHJldCA9IE1hdGgubWF4KCQuX3ByZXZQcm9ncmVzcywgcmV0KTsgLy8gV2UgZG9uJ3Qgd2FudCB0byBsb3NlIHBlcmNlbnRhZ2VzIHdoZW4gYW4gdXBsb2FkIGlzIHBhdXNlZFxuICAgICAgICAkLl9wcmV2UHJvZ3Jlc3MgPSByZXQ7XG4gICAgICAgIHJldHVybihyZXQpO1xuICAgICAgfTtcbiAgICAgICQuaXNVcGxvYWRpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdXBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICRoLmVhY2goJC5jaHVua3MsIGZ1bmN0aW9uKGNodW5rKXtcbiAgICAgICAgICBpZihjaHVuay5zdGF0dXMoKT09J3VwbG9hZGluZycpIHtcbiAgICAgICAgICAgIHVwbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4oZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybih1cGxvYWRpbmcpO1xuICAgICAgfTtcbiAgICAgICQuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvdXRzdGFuZGluZyA9IGZhbHNlO1xuICAgICAgICAkaC5lYWNoKCQuY2h1bmtzLCBmdW5jdGlvbihjaHVuayl7XG4gICAgICAgICAgdmFyIHN0YXR1cyA9IGNodW5rLnN0YXR1cygpO1xuICAgICAgICAgIGlmKHN0YXR1cz09J3BlbmRpbmcnIHx8IHN0YXR1cz09J3VwbG9hZGluZycgfHwgY2h1bmsucHJlcHJvY2Vzc1N0YXRlID09PSAxKSB7XG4gICAgICAgICAgICBvdXRzdGFuZGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4oZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybighb3V0c3RhbmRpbmcpO1xuICAgICAgfTtcbiAgICAgICQucGF1c2UgPSBmdW5jdGlvbihwYXVzZSl7XG4gICAgICAgICAgaWYodHlwZW9mKHBhdXNlKT09PSd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgICAgJC5fcGF1c2UgPSAoJC5fcGF1c2UgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAkLl9wYXVzZSA9IHBhdXNlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICAkLmlzUGF1c2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkLl9wYXVzZTtcbiAgICAgIH07XG5cblxuICAgICAgLy8gQm9vdHN0cmFwIGFuZCByZXR1cm5cbiAgICAgICQucmVzdW1hYmxlT2JqLmZpcmUoJ2NodW5raW5nU3RhcnQnLCAkKTtcbiAgICAgICQuYm9vdHN0cmFwKCk7XG4gICAgICByZXR1cm4odGhpcyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBSZXN1bWFibGVDaHVuayhyZXN1bWFibGVPYmosIGZpbGVPYmosIG9mZnNldCwgY2FsbGJhY2spe1xuICAgICAgdmFyICQgPSB0aGlzO1xuICAgICAgJC5vcHRzID0ge307XG4gICAgICAkLmdldE9wdCA9IHJlc3VtYWJsZU9iai5nZXRPcHQ7XG4gICAgICAkLnJlc3VtYWJsZU9iaiA9IHJlc3VtYWJsZU9iajtcbiAgICAgICQuZmlsZU9iaiA9IGZpbGVPYmo7XG4gICAgICAkLmZpbGVPYmpTaXplID0gZmlsZU9iai5zaXplO1xuICAgICAgJC5maWxlT2JqVHlwZSA9IGZpbGVPYmouZmlsZS50eXBlO1xuICAgICAgJC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAkLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAkLmxhc3RQcm9ncmVzc0NhbGxiYWNrID0gKG5ldyBEYXRlKTtcbiAgICAgICQudGVzdGVkID0gZmFsc2U7XG4gICAgICAkLnJldHJpZXMgPSAwO1xuICAgICAgJC5wZW5kaW5nUmV0cnkgPSBmYWxzZTtcbiAgICAgICQucHJlcHJvY2Vzc1N0YXRlID0gMDsgLy8gMCA9IHVucHJvY2Vzc2VkLCAxID0gcHJvY2Vzc2luZywgMiA9IGZpbmlzaGVkXG5cbiAgICAgIC8vIENvbXB1dGVkIHByb3BlcnRpZXNcbiAgICAgIHZhciBjaHVua1NpemUgPSAkLmdldE9wdCgnY2h1bmtTaXplJyk7XG4gICAgICAkLmxvYWRlZCA9IDA7XG4gICAgICAkLnN0YXJ0Qnl0ZSA9ICQub2Zmc2V0KmNodW5rU2l6ZTtcbiAgICAgICQuZW5kQnl0ZSA9IE1hdGgubWluKCQuZmlsZU9ialNpemUsICgkLm9mZnNldCsxKSpjaHVua1NpemUpO1xuICAgICAgaWYgKCQuZmlsZU9ialNpemUtJC5lbmRCeXRlIDwgY2h1bmtTaXplICYmICEkLmdldE9wdCgnZm9yY2VDaHVua1NpemUnKSkge1xuICAgICAgICAvLyBUaGUgbGFzdCBjaHVuayB3aWxsIGJlIGJpZ2dlciB0aGFuIHRoZSBjaHVuayBzaXplLCBidXQgbGVzcyB0aGFuIDIqY2h1bmtTaXplXG4gICAgICAgICQuZW5kQnl0ZSA9ICQuZmlsZU9ialNpemU7XG4gICAgICB9XG4gICAgICAkLnhociA9IG51bGw7XG5cbiAgICAgIC8vIHRlc3QoKSBtYWtlcyBhIEdFVCByZXF1ZXN0IHdpdGhvdXQgYW55IGRhdGEgdG8gc2VlIGlmIHRoZSBjaHVuayBoYXMgYWxyZWFkeSBiZWVuIHVwbG9hZGVkIGluIGEgcHJldmlvdXMgc2Vzc2lvblxuICAgICAgJC50ZXN0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gU2V0IHVwIHJlcXVlc3QgYW5kIGxpc3RlbiBmb3IgZXZlbnRcbiAgICAgICAgJC54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICB2YXIgdGVzdEhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgICAkLnRlc3RlZCA9IHRydWU7XG4gICAgICAgICAgdmFyIHN0YXR1cyA9ICQuc3RhdHVzKCk7XG4gICAgICAgICAgaWYoc3RhdHVzPT0nc3VjY2VzcycpIHtcbiAgICAgICAgICAgICQuY2FsbGJhY2soc3RhdHVzLCAkLm1lc3NhZ2UoKSk7XG4gICAgICAgICAgICAkLnJlc3VtYWJsZU9iai51cGxvYWROZXh0Q2h1bmsoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5zZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAkLnhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGVzdEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgJC54aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0ZXN0SGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAkLnhoci5hZGRFdmVudExpc3RlbmVyKCd0aW1lb3V0JywgdGVzdEhhbmRsZXIsIGZhbHNlKTtcblxuICAgICAgICAvLyBBZGQgZGF0YSBmcm9tIHRoZSBxdWVyeSBvcHRpb25zXG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIHBhcmFtZXRlck5hbWVzcGFjZSA9ICQuZ2V0T3B0KCdwYXJhbWV0ZXJOYW1lc3BhY2UnKTtcbiAgICAgICAgdmFyIGN1c3RvbVF1ZXJ5ID0gJC5nZXRPcHQoJ3F1ZXJ5Jyk7XG4gICAgICAgIGlmKHR5cGVvZiBjdXN0b21RdWVyeSA9PSAnZnVuY3Rpb24nKSBjdXN0b21RdWVyeSA9IGN1c3RvbVF1ZXJ5KCQuZmlsZU9iaiwgJCk7XG4gICAgICAgICRoLmVhY2goY3VzdG9tUXVlcnksIGZ1bmN0aW9uKGssdil7XG4gICAgICAgICAgcGFyYW1zLnB1c2goW2VuY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXJOYW1lc3BhY2UrayksIGVuY29kZVVSSUNvbXBvbmVudCh2KV0uam9pbignPScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBleHRyYSBkYXRhIHRvIGlkZW50aWZ5IGNodW5rXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcy5jb25jYXQoXG4gICAgICAgICAgW1xuICAgICAgICAgICAgLy8gZGVmaW5lIGtleS92YWx1ZSBwYWlycyBmb3IgYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBbJ2NodW5rTnVtYmVyUGFyYW1ldGVyTmFtZScsICQub2Zmc2V0ICsgMV0sXG4gICAgICAgICAgICBbJ2NodW5rU2l6ZVBhcmFtZXRlck5hbWUnLCAkLmdldE9wdCgnY2h1bmtTaXplJyldLFxuICAgICAgICAgICAgWydjdXJyZW50Q2h1bmtTaXplUGFyYW1ldGVyTmFtZScsICQuZW5kQnl0ZSAtICQuc3RhcnRCeXRlXSxcbiAgICAgICAgICAgIFsndG90YWxTaXplUGFyYW1ldGVyTmFtZScsICQuZmlsZU9ialNpemVdLFxuICAgICAgICAgICAgWyd0eXBlUGFyYW1ldGVyTmFtZScsICQuZmlsZU9ialR5cGVdLFxuICAgICAgICAgICAgWydpZGVudGlmaWVyUGFyYW1ldGVyTmFtZScsICQuZmlsZU9iai51bmlxdWVJZGVudGlmaWVyXSxcbiAgICAgICAgICAgIFsnZmlsZU5hbWVQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqLmZpbGVOYW1lXSxcbiAgICAgICAgICAgIFsncmVsYXRpdmVQYXRoUGFyYW1ldGVyTmFtZScsICQuZmlsZU9iai5yZWxhdGl2ZVBhdGhdLFxuICAgICAgICAgICAgWyd0b3RhbENodW5rc1BhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmouY2h1bmtzLmxlbmd0aF1cbiAgICAgICAgICBdLmZpbHRlcihmdW5jdGlvbihwYWlyKXtcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgaXRlbXMgdGhhdCByZXNvbHZlIHRvIHRydXRoeSB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGkuZS4gZXhjbHVkZSBmYWxzZSwgbnVsbCwgdW5kZWZpbmVkIGFuZCBlbXB0eSBzdHJpbmdzXG4gICAgICAgICAgICByZXR1cm4gJC5nZXRPcHQocGFpclswXSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKHBhaXIpe1xuICAgICAgICAgICAgLy8gbWFwIGVhY2gga2V5L3ZhbHVlIHBhaXIgdG8gaXRzIGZpbmFsIGZvcm1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIHBhcmFtZXRlck5hbWVzcGFjZSArICQuZ2V0T3B0KHBhaXJbMF0pLFxuICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQocGFpclsxXSlcbiAgICAgICAgICAgIF0uam9pbignPScpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIC8vIEFwcGVuZCB0aGUgcmVsZXZhbnQgY2h1bmsgYW5kIHNlbmQgaXRcbiAgICAgICAgJC54aHIub3BlbigkLmdldE9wdCgndGVzdE1ldGhvZCcpLCAkaC5nZXRUYXJnZXQoJ3Rlc3QnLCBwYXJhbXMpKTtcbiAgICAgICAgJC54aHIudGltZW91dCA9ICQuZ2V0T3B0KCd4aHJUaW1lb3V0Jyk7XG4gICAgICAgICQueGhyLndpdGhDcmVkZW50aWFscyA9ICQuZ2V0T3B0KCd3aXRoQ3JlZGVudGlhbHMnKTtcbiAgICAgICAgLy8gQWRkIGRhdGEgZnJvbSBoZWFkZXIgb3B0aW9uc1xuICAgICAgICB2YXIgY3VzdG9tSGVhZGVycyA9ICQuZ2V0T3B0KCdoZWFkZXJzJyk7XG4gICAgICAgIGlmKHR5cGVvZiBjdXN0b21IZWFkZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3VzdG9tSGVhZGVycyA9IGN1c3RvbUhlYWRlcnMoJC5maWxlT2JqLCAkKTtcbiAgICAgICAgfVxuICAgICAgICAkaC5lYWNoKGN1c3RvbUhlYWRlcnMsIGZ1bmN0aW9uKGssdikge1xuICAgICAgICAgICQueGhyLnNldFJlcXVlc3RIZWFkZXIoaywgdik7XG4gICAgICAgIH0pO1xuICAgICAgICAkLnhoci5zZW5kKG51bGwpO1xuICAgICAgfTtcblxuICAgICAgJC5wcmVwcm9jZXNzRmluaXNoZWQgPSBmdW5jdGlvbigpe1xuICAgICAgICAkLnByZXByb2Nlc3NTdGF0ZSA9IDI7XG4gICAgICAgICQuc2VuZCgpO1xuICAgICAgfTtcblxuICAgICAgLy8gc2VuZCgpIHVwbG9hZHMgdGhlIGFjdHVhbCBkYXRhIGluIGEgUE9TVCBjYWxsXG4gICAgICAkLnNlbmQgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcHJlcHJvY2VzcyA9ICQuZ2V0T3B0KCdwcmVwcm9jZXNzJyk7XG4gICAgICAgIGlmKHR5cGVvZiBwcmVwcm9jZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc3dpdGNoKCQucHJlcHJvY2Vzc1N0YXRlKSB7XG4gICAgICAgICAgY2FzZSAwOiAkLnByZXByb2Nlc3NTdGF0ZSA9IDE7IHByZXByb2Nlc3MoJCk7IHJldHVybjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybjtcbiAgICAgICAgICBjYXNlIDI6IGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZigkLmdldE9wdCgndGVzdENodW5rcycpICYmICEkLnRlc3RlZCkge1xuICAgICAgICAgICQudGVzdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB1cCByZXF1ZXN0IGFuZCBsaXN0ZW4gZm9yIGV2ZW50XG4gICAgICAgICQueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgLy8gUHJvZ3Jlc3NcbiAgICAgICAgJC54aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgaWYoIChuZXcgRGF0ZSkgLSAkLmxhc3RQcm9ncmVzc0NhbGxiYWNrID4gJC5nZXRPcHQoJ3Rocm90dGxlUHJvZ3Jlc3NDYWxsYmFja3MnKSAqIDEwMDAgKSB7XG4gICAgICAgICAgICAkLmNhbGxiYWNrKCdwcm9ncmVzcycpO1xuICAgICAgICAgICAgJC5sYXN0UHJvZ3Jlc3NDYWxsYmFjayA9IChuZXcgRGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgICQubG9hZGVkPWUubG9hZGVkfHwwO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICQubG9hZGVkID0gMDtcbiAgICAgICAgJC5wZW5kaW5nUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgJC5jYWxsYmFjaygncHJvZ3Jlc3MnKTtcblxuICAgICAgICAvLyBEb25lIChlaXRoZXIgZG9uZSwgZmFpbGVkIG9yIHJldHJ5KVxuICAgICAgICB2YXIgZG9uZUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgICB2YXIgc3RhdHVzID0gJC5zdGF0dXMoKTtcbiAgICAgICAgICBpZihzdGF0dXM9PSdzdWNjZXNzJ3x8c3RhdHVzPT0nZXJyb3InKSB7XG4gICAgICAgICAgICAkLmNhbGxiYWNrKHN0YXR1cywgJC5tZXNzYWdlKCkpO1xuICAgICAgICAgICAgJC5yZXN1bWFibGVPYmoudXBsb2FkTmV4dENodW5rKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuY2FsbGJhY2soJ3JldHJ5JywgJC5tZXNzYWdlKCkpO1xuICAgICAgICAgICAgJC5hYm9ydCgpO1xuICAgICAgICAgICAgJC5yZXRyaWVzKys7XG4gICAgICAgICAgICB2YXIgcmV0cnlJbnRlcnZhbCA9ICQuZ2V0T3B0KCdjaHVua1JldHJ5SW50ZXJ2YWwnKTtcbiAgICAgICAgICAgIGlmKHJldHJ5SW50ZXJ2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAkLnBlbmRpbmdSZXRyeSA9IHRydWU7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoJC5zZW5kLCByZXRyeUludGVydmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICQuc2VuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJC54aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGRvbmVIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICQueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZG9uZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgJC54aHIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIGRvbmVIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRoZSBiYXNpYyBxdWVyeSBkYXRhIGZyb20gUmVzdW1hYmxlXG4gICAgICAgIHZhciBxdWVyeSA9IFtcbiAgICAgICAgICBbJ2NodW5rTnVtYmVyUGFyYW1ldGVyTmFtZScsICQub2Zmc2V0ICsgMV0sXG4gICAgICAgICAgWydjaHVua1NpemVQYXJhbWV0ZXJOYW1lJywgJC5nZXRPcHQoJ2NodW5rU2l6ZScpXSxcbiAgICAgICAgICBbJ2N1cnJlbnRDaHVua1NpemVQYXJhbWV0ZXJOYW1lJywgJC5lbmRCeXRlIC0gJC5zdGFydEJ5dGVdLFxuICAgICAgICAgIFsndG90YWxTaXplUGFyYW1ldGVyTmFtZScsICQuZmlsZU9ialNpemVdLFxuICAgICAgICAgIFsndHlwZVBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmpUeXBlXSxcbiAgICAgICAgICBbJ2lkZW50aWZpZXJQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqLnVuaXF1ZUlkZW50aWZpZXJdLFxuICAgICAgICAgIFsnZmlsZU5hbWVQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqLmZpbGVOYW1lXSxcbiAgICAgICAgICBbJ3JlbGF0aXZlUGF0aFBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmoucmVsYXRpdmVQYXRoXSxcbiAgICAgICAgICBbJ3RvdGFsQ2h1bmtzUGFyYW1ldGVyTmFtZScsICQuZmlsZU9iai5jaHVua3MubGVuZ3RoXSxcbiAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24ocGFpcil7XG4gICAgICAgICAgLy8gaW5jbHVkZSBpdGVtcyB0aGF0IHJlc29sdmUgdG8gdHJ1dGh5IHZhbHVlc1xuICAgICAgICAgIC8vIGkuZS4gZXhjbHVkZSBmYWxzZSwgbnVsbCwgdW5kZWZpbmVkIGFuZCBlbXB0eSBzdHJpbmdzXG4gICAgICAgICAgcmV0dXJuICQuZ2V0T3B0KHBhaXJbMF0pO1xuICAgICAgICB9KVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKHF1ZXJ5LCBwYWlyKXtcbiAgICAgICAgICAvLyBhc3NpZ24gcXVlcnkga2V5L3ZhbHVlXG4gICAgICAgICAgcXVlcnlbJC5nZXRPcHQocGFpclswXSldID0gcGFpclsxXTtcbiAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gTWl4IGluIGN1c3RvbSBkYXRhXG4gICAgICAgIHZhciBjdXN0b21RdWVyeSA9ICQuZ2V0T3B0KCdxdWVyeScpO1xuICAgICAgICBpZih0eXBlb2YgY3VzdG9tUXVlcnkgPT0gJ2Z1bmN0aW9uJykgY3VzdG9tUXVlcnkgPSBjdXN0b21RdWVyeSgkLmZpbGVPYmosICQpO1xuICAgICAgICAkaC5lYWNoKGN1c3RvbVF1ZXJ5LCBmdW5jdGlvbihrLHYpe1xuICAgICAgICAgIHF1ZXJ5W2tdID0gdjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZ1bmMgPSAoJC5maWxlT2JqLmZpbGUuc2xpY2UgPyAnc2xpY2UnIDogKCQuZmlsZU9iai5maWxlLm1velNsaWNlID8gJ21velNsaWNlJyA6ICgkLmZpbGVPYmouZmlsZS53ZWJraXRTbGljZSA/ICd3ZWJraXRTbGljZScgOiAnc2xpY2UnKSkpO1xuICAgICAgICB2YXIgYnl0ZXMgPSAkLmZpbGVPYmouZmlsZVtmdW5jXSgkLnN0YXJ0Qnl0ZSwgJC5lbmRCeXRlLCAkLmdldE9wdCgnc2V0Q2h1bmtUeXBlRnJvbUZpbGUnKSA/ICQuZmlsZU9iai5maWxlLnR5cGUgOiBcIlwiKTtcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuICAgICAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICAgICAgdmFyIHBhcmFtZXRlck5hbWVzcGFjZSA9ICQuZ2V0T3B0KCdwYXJhbWV0ZXJOYW1lc3BhY2UnKTtcbiAgICAgICAgICAgICAgICBpZiAoJC5nZXRPcHQoJ21ldGhvZCcpID09PSAnb2N0ZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBkYXRhIGZyb20gdGhlIHF1ZXJ5IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGJ5dGVzO1xuICAgICAgICAgICAgICAgICAgICAkaC5lYWNoKHF1ZXJ5LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goW2VuY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXJOYW1lc3BhY2UgKyBrKSwgZW5jb2RlVVJJQ29tcG9uZW50KHYpXS5qb2luKCc9JykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZGF0YSBmcm9tIHRoZSBxdWVyeSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgJGguZWFjaChxdWVyeSwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYXBwZW5kKHBhcmFtZXRlck5hbWVzcGFjZSArIGssIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goW2VuY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXJOYW1lc3BhY2UgKyBrKSwgZW5jb2RlVVJJQ29tcG9uZW50KHYpXS5qb2luKCc9JykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuZ2V0T3B0KCdjaHVua0Zvcm1hdCcpID09ICdibG9iJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hcHBlbmQocGFyYW1ldGVyTmFtZXNwYWNlICsgJC5nZXRPcHQoJ2ZpbGVQYXJhbWV0ZXJOYW1lJyksIGJ5dGVzLCAkLmZpbGVPYmouZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCQuZ2V0T3B0KCdjaHVua0Zvcm1hdCcpID09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFwcGVuZChwYXJhbWV0ZXJOYW1lc3BhY2UgKyAkLmdldE9wdCgnZmlsZVBhcmFtZXRlck5hbWUnKSwgZnIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLnhoci5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZnIucmVhZEFzRGF0YVVSTChieXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhcmdldCA9ICRoLmdldFRhcmdldCgndXBsb2FkJywgcGFyYW1zKTtcbiAgICAgICAgdmFyIG1ldGhvZCA9ICQuZ2V0T3B0KCd1cGxvYWRNZXRob2QnKTtcblxuICAgICAgICAkLnhoci5vcGVuKG1ldGhvZCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKCQuZ2V0T3B0KCdtZXRob2QnKSA9PT0gJ29jdGV0Jykge1xuICAgICAgICAgICQueGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfVxuICAgICAgICAkLnhoci50aW1lb3V0ID0gJC5nZXRPcHQoJ3hoclRpbWVvdXQnKTtcbiAgICAgICAgJC54aHIud2l0aENyZWRlbnRpYWxzID0gJC5nZXRPcHQoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgICAgICAvLyBBZGQgZGF0YSBmcm9tIGhlYWRlciBvcHRpb25zXG4gICAgICAgIHZhciBjdXN0b21IZWFkZXJzID0gJC5nZXRPcHQoJ2hlYWRlcnMnKTtcbiAgICAgICAgaWYodHlwZW9mIGN1c3RvbUhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjdXN0b21IZWFkZXJzID0gY3VzdG9tSGVhZGVycygkLmZpbGVPYmosICQpO1xuICAgICAgICB9XG5cbiAgICAgICAgJGguZWFjaChjdXN0b21IZWFkZXJzLCBmdW5jdGlvbihrLHYpIHtcbiAgICAgICAgICAkLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGssIHYpO1xuICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICgkLmdldE9wdCgnY2h1bmtGb3JtYXQnKSA9PSAnYmxvYicpIHtcbiAgICAgICAgICAgICAgICAgICAgJC54aHIuc2VuZChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgJC5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIEFib3J0IGFuZCByZXNldFxuICAgICAgICBpZigkLnhocikgJC54aHIuYWJvcnQoKTtcbiAgICAgICAgJC54aHIgPSBudWxsO1xuICAgICAgfTtcbiAgICAgICQuc3RhdHVzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gUmV0dXJuczogJ3BlbmRpbmcnLCAndXBsb2FkaW5nJywgJ3N1Y2Nlc3MnLCAnZXJyb3InXG4gICAgICAgIGlmKCQucGVuZGluZ1JldHJ5KSB7XG4gICAgICAgICAgLy8gaWYgcGVuZGluZyByZXRyeSB0aGVuIHRoYXQncyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBhY3RpdmVseSB1cGxvYWRpbmcsXG4gICAgICAgICAgLy8gdGhlcmUgbWlnaHQganVzdCBiZSBhIHNsaWdodCBkZWxheSBiZWZvcmUgdGhlIHJldHJ5IHN0YXJ0c1xuICAgICAgICAgIHJldHVybigndXBsb2FkaW5nJyk7XG4gICAgICAgIH0gZWxzZSBpZighJC54aHIpIHtcbiAgICAgICAgICByZXR1cm4oJ3BlbmRpbmcnKTtcbiAgICAgICAgfSBlbHNlIGlmKCQueGhyLnJlYWR5U3RhdGU8NCkge1xuICAgICAgICAgIC8vIFN0YXR1cyBpcyByZWFsbHkgJ09QRU5FRCcsICdIRUFERVJTX1JFQ0VJVkVEJyBvciAnTE9BRElORycgLSBtZWFuaW5nIHRoYXQgc3R1ZmYgaXMgaGFwcGVuaW5nXG4gICAgICAgICAgcmV0dXJuKCd1cGxvYWRpbmcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZigkLnhoci5zdGF0dXMgPT0gMjAwIHx8ICQueGhyLnN0YXR1cyA9PSAyMDEpIHtcbiAgICAgICAgICAgIC8vIEhUVFAgMjAwLCAyMDEgKGNyZWF0ZWQpXG4gICAgICAgICAgICByZXR1cm4oJ3N1Y2Nlc3MnKTtcbiAgICAgICAgICB9IGVsc2UgaWYoJGguY29udGFpbnMoJC5nZXRPcHQoJ3Blcm1hbmVudEVycm9ycycpLCAkLnhoci5zdGF0dXMpIHx8ICQucmV0cmllcyA+PSAkLmdldE9wdCgnbWF4Q2h1bmtSZXRyaWVzJykpIHtcbiAgICAgICAgICAgIC8vIEhUVFAgNDE1LzUwMC81MDEsIHBlcm1hbmVudCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuKCdlcnJvcicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCB3ZSdsbCByZXNldCBhbmQgcXVldWUgYSByZXRyeVxuICAgICAgICAgICAgLy8gYSBsaWtlbHkgY2FzZSBmb3IgdGhpcyB3b3VsZCBiZSA1MDMgc2VydmljZSB1bmF2YWlsYWJsZVxuICAgICAgICAgICAgJC5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuKCdwZW5kaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgJC5tZXNzYWdlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuKCQueGhyID8gJC54aHIucmVzcG9uc2VUZXh0IDogJycpO1xuICAgICAgfTtcbiAgICAgICQucHJvZ3Jlc3MgPSBmdW5jdGlvbihyZWxhdGl2ZSl7XG4gICAgICAgIGlmKHR5cGVvZihyZWxhdGl2ZSk9PT0ndW5kZWZpbmVkJykgcmVsYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGZhY3RvciA9IChyZWxhdGl2ZSA/ICgkLmVuZEJ5dGUtJC5zdGFydEJ5dGUpLyQuZmlsZU9ialNpemUgOiAxKTtcbiAgICAgICAgaWYoJC5wZW5kaW5nUmV0cnkpIHJldHVybigwKTtcbiAgICAgICAgaWYoISQueGhyIHx8ICEkLnhoci5zdGF0dXMpIGZhY3Rvcio9Ljk1O1xuICAgICAgICB2YXIgcyA9ICQuc3RhdHVzKCk7XG4gICAgICAgIHN3aXRjaChzKXtcbiAgICAgICAgY2FzZSAnc3VjY2Vzcyc6XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICByZXR1cm4oMSpmYWN0b3IpO1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgICByZXR1cm4oMCpmYWN0b3IpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybigkLmxvYWRlZC8oJC5lbmRCeXRlLSQuc3RhcnRCeXRlKSpmYWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFFVRVVFXG4gICAgJC51cGxvYWROZXh0Q2h1bmsgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgIC8vIEluIHNvbWUgY2FzZXMgKHN1Y2ggYXMgdmlkZW9zKSBpdCdzIHJlYWxseSBoYW5keSB0byB1cGxvYWQgdGhlIGZpcnN0XG4gICAgICAvLyBhbmQgbGFzdCBjaHVuayBvZiBhIGZpbGUgcXVpY2tseTsgdGhpcyBsZXQncyB0aGUgc2VydmVyIGNoZWNrIHRoZSBmaWxlJ3NcbiAgICAgIC8vIG1ldGFkYXRhIGFuZCBkZXRlcm1pbmUgaWYgdGhlcmUncyBldmVuIGEgcG9pbnQgaW4gY29udGludWluZy5cbiAgICAgIGlmICgkLmdldE9wdCgncHJpb3JpdGl6ZUZpcnN0QW5kTGFzdENodW5rJykpIHtcbiAgICAgICAgJGguZWFjaCgkLmZpbGVzLCBmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgICBpZihmaWxlLmNodW5rcy5sZW5ndGggJiYgZmlsZS5jaHVua3NbMF0uc3RhdHVzKCk9PSdwZW5kaW5nJyAmJiBmaWxlLmNodW5rc1swXS5wcmVwcm9jZXNzU3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgIGZpbGUuY2h1bmtzWzBdLnNlbmQoKTtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybihmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGZpbGUuY2h1bmtzLmxlbmd0aD4xICYmIGZpbGUuY2h1bmtzW2ZpbGUuY2h1bmtzLmxlbmd0aC0xXS5zdGF0dXMoKT09J3BlbmRpbmcnICYmIGZpbGUuY2h1bmtzW2ZpbGUuY2h1bmtzLmxlbmd0aC0xXS5wcmVwcm9jZXNzU3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgIGZpbGUuY2h1bmtzW2ZpbGUuY2h1bmtzLmxlbmd0aC0xXS5zZW5kKCk7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4oZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGZvdW5kKSByZXR1cm4odHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgc2ltcGx5IGxvb2sgZm9yIHRoZSBuZXh0LCBiZXN0IHRoaW5nIHRvIHVwbG9hZFxuICAgICAgJGguZWFjaCgkLmZpbGVzLCBmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgaWYoZmlsZS5pc1BhdXNlZCgpPT09ZmFsc2Upe1xuICAgICAgICAgJGguZWFjaChmaWxlLmNodW5rcywgZnVuY3Rpb24oY2h1bmspe1xuICAgICAgICAgICBpZihjaHVuay5zdGF0dXMoKT09J3BlbmRpbmcnICYmIGNodW5rLnByZXByb2Nlc3NTdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgIGNodW5rLnNlbmQoKTtcbiAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgcmV0dXJuKGZhbHNlKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmKGZvdW5kKSByZXR1cm4oZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICBpZihmb3VuZCkgcmV0dXJuKHRydWUpO1xuXG4gICAgICAvLyBUaGUgYXJlIG5vIG1vcmUgb3V0c3RhbmRpbmcgY2h1bmtzIHRvIHVwbG9hZCwgY2hlY2sgaXMgZXZlcnl0aGluZyBpcyBkb25lXG4gICAgICB2YXIgb3V0c3RhbmRpbmcgPSBmYWxzZTtcbiAgICAgICRoLmVhY2goJC5maWxlcywgZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgIGlmKCFmaWxlLmlzQ29tcGxldGUoKSkge1xuICAgICAgICAgIG91dHN0YW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4oZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmKCFvdXRzdGFuZGluZykge1xuICAgICAgICAvLyBBbGwgY2h1bmtzIGhhdmUgYmVlbiB1cGxvYWRlZCwgY29tcGxldGVcbiAgICAgICAgJC5maXJlKCdjb21wbGV0ZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuKGZhbHNlKTtcbiAgICB9O1xuXG5cbiAgICAvLyBQVUJMSUMgTUVUSE9EUyBGT1IgUkVTVU1BQkxFLkpTXG4gICAgJC5hc3NpZ25Ccm93c2UgPSBmdW5jdGlvbihkb21Ob2RlcywgaXNEaXJlY3Rvcnkpe1xuICAgICAgaWYodHlwZW9mKGRvbU5vZGVzLmxlbmd0aCk9PSd1bmRlZmluZWQnKSBkb21Ob2RlcyA9IFtkb21Ob2Rlc107XG5cbiAgICAgICRoLmVhY2goZG9tTm9kZXMsIGZ1bmN0aW9uKGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIGlucHV0O1xuICAgICAgICBpZihkb21Ob2RlLnRhZ05hbWU9PT0nSU5QVVQnICYmIGRvbU5vZGUudHlwZT09PSdmaWxlJyl7XG4gICAgICAgICAgaW5wdXQgPSBkb21Ob2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZmlsZScpO1xuICAgICAgICAgIGlucHV0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgZG9tTm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpbnB1dC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgIGlucHV0LnN0eWxlLmRpc3BsYXk9J2Jsb2NrJztcbiAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBpbnB1dC5jbGljaygpO1xuICAgICAgICAgICAgaW5wdXQuc3R5bGUuZGlzcGxheT0nbm9uZSc7XG4gICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIGRvbU5vZGUuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhGaWxlcyA9ICQuZ2V0T3B0KCdtYXhGaWxlcycpO1xuICAgICAgICBpZiAodHlwZW9mKG1heEZpbGVzKT09PSd1bmRlZmluZWQnfHxtYXhGaWxlcyE9MSl7XG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnbXVsdGlwbGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZihpc0RpcmVjdG9yeSl7XG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCd3ZWJraXRkaXJlY3RvcnknLCAnd2Via2l0ZGlyZWN0b3J5Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCd3ZWJraXRkaXJlY3RvcnknKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsZVR5cGVzID0gJC5nZXRPcHQoJ2ZpbGVUeXBlJyk7XG4gICAgICAgIGlmICh0eXBlb2YgKGZpbGVUeXBlcykgIT09ICd1bmRlZmluZWQnICYmIGZpbGVUeXBlcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYWNjZXB0JywgZmlsZVR5cGVzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gJy4nICsgZSB9KS5qb2luKCcsJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYWNjZXB0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiBuZXcgZmlsZXMgYXJlIGFkZGVkLCBzaW1wbHkgYXBwZW5kIHRoZW0gdG8gdGhlIG92ZXJhbGwgbGlzdFxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICBhcHBlbmRGaWxlc0Zyb21GaWxlTGlzdChlLnRhcmdldC5maWxlcyxlKTtcbiAgICAgICAgICB2YXIgY2xlYXJJbnB1dCA9ICQuZ2V0T3B0KCdjbGVhcklucHV0Jyk7XG4gICAgICAgICAgaWYgKGNsZWFySW5wdXQpIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgICQuYXNzaWduRHJvcCA9IGZ1bmN0aW9uKGRvbU5vZGVzKXtcbiAgICAgIGlmKHR5cGVvZihkb21Ob2Rlcy5sZW5ndGgpPT0ndW5kZWZpbmVkJykgZG9tTm9kZXMgPSBbZG9tTm9kZXNdO1xuXG4gICAgICAkaC5lYWNoKGRvbU5vZGVzLCBmdW5jdGlvbihkb21Ob2RlKSB7XG4gICAgICAgIGRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBwcmV2ZW50RGVmYXVsdCwgZmFsc2UpO1xuICAgICAgICBkb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIHByZXZlbnREZWZhdWx0LCBmYWxzZSk7XG4gICAgICAgIGRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIG9uRHJvcCwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAkLnVuQXNzaWduRHJvcCA9IGZ1bmN0aW9uKGRvbU5vZGVzKSB7XG4gICAgICBpZiAodHlwZW9mKGRvbU5vZGVzLmxlbmd0aCkgPT0gJ3VuZGVmaW5lZCcpIGRvbU5vZGVzID0gW2RvbU5vZGVzXTtcblxuICAgICAgJGguZWFjaChkb21Ob2RlcywgZnVuY3Rpb24oZG9tTm9kZSkge1xuICAgICAgICBkb21Ob2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgcHJldmVudERlZmF1bHQpO1xuICAgICAgICBkb21Ob2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgZG9tTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgb25Ecm9wKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgJC5pc1VwbG9hZGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdXBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAkaC5lYWNoKCQuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICBpZiAoZmlsZS5pc1VwbG9hZGluZygpKSB7XG4gICAgICAgICAgdXBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4oZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybih1cGxvYWRpbmcpO1xuICAgIH07XG4gICAgJC51cGxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHN0YXJ0IHRvbyBtYW55IHVwbG9hZHMgYXQgb25jZVxuICAgICAgaWYoJC5pc1VwbG9hZGluZygpKSByZXR1cm47XG4gICAgICAvLyBLaWNrIG9mZiB0aGUgcXVldWVcbiAgICAgICQuZmlyZSgndXBsb2FkU3RhcnQnKTtcbiAgICAgIGZvciAodmFyIG51bT0xOyBudW08PSQuZ2V0T3B0KCdzaW11bHRhbmVvdXNVcGxvYWRzJyk7IG51bSsrKSB7XG4gICAgICAgICQudXBsb2FkTmV4dENodW5rKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAkLnBhdXNlID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIFJlc3VtZSBhbGwgY2h1bmtzIGN1cnJlbnRseSBiZWluZyB1cGxvYWRlZFxuICAgICAgJGguZWFjaCgkLmZpbGVzLCBmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgZmlsZS5hYm9ydCgpO1xuICAgICAgfSk7XG4gICAgICAkLmZpcmUoJ3BhdXNlJyk7XG4gICAgfTtcbiAgICAkLmNhbmNlbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAkLmZpcmUoJ2JlZm9yZUNhbmNlbCcpO1xuICAgICAgZm9yKHZhciBpID0gJC5maWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAkLmZpbGVzW2ldLmNhbmNlbCgpO1xuICAgICAgfVxuICAgICAgJC5maXJlKCdjYW5jZWwnKTtcbiAgICB9O1xuICAgICQucHJvZ3Jlc3MgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRvdGFsRG9uZSA9IDA7XG4gICAgICB2YXIgdG90YWxTaXplID0gMDtcbiAgICAgIC8vIFJlc3VtZSBhbGwgY2h1bmtzIGN1cnJlbnRseSBiZWluZyB1cGxvYWRlZFxuICAgICAgJGguZWFjaCgkLmZpbGVzLCBmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgdG90YWxEb25lICs9IGZpbGUucHJvZ3Jlc3MoKSpmaWxlLnNpemU7XG4gICAgICAgIHRvdGFsU2l6ZSArPSBmaWxlLnNpemU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybih0b3RhbFNpemU+MCA/IHRvdGFsRG9uZS90b3RhbFNpemUgOiAwKTtcbiAgICB9O1xuICAgICQuYWRkRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIGV2ZW50KXtcbiAgICAgIGFwcGVuZEZpbGVzRnJvbUZpbGVMaXN0KFtmaWxlXSwgZXZlbnQpO1xuICAgIH07XG4gICAgJC5hZGRGaWxlcyA9IGZ1bmN0aW9uKGZpbGVzLCBldmVudCl7XG4gICAgICBhcHBlbmRGaWxlc0Zyb21GaWxlTGlzdChmaWxlcywgZXZlbnQpO1xuICAgIH07XG4gICAgJC5yZW1vdmVGaWxlID0gZnVuY3Rpb24oZmlsZSl7XG4gICAgICBmb3IodmFyIGkgPSAkLmZpbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmKCQuZmlsZXNbaV0gPT09IGZpbGUpIHtcbiAgICAgICAgICAkLmZpbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgJC5nZXRGcm9tVW5pcXVlSWRlbnRpZmllciA9IGZ1bmN0aW9uKHVuaXF1ZUlkZW50aWZpZXIpe1xuICAgICAgdmFyIHJldCA9IGZhbHNlO1xuICAgICAgJGguZWFjaCgkLmZpbGVzLCBmdW5jdGlvbihmKXtcbiAgICAgICAgaWYoZi51bmlxdWVJZGVudGlmaWVyPT11bmlxdWVJZGVudGlmaWVyKSByZXQgPSBmO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ocmV0KTtcbiAgICB9O1xuICAgICQuZ2V0U2l6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdG90YWxTaXplID0gMDtcbiAgICAgICRoLmVhY2goJC5maWxlcywgZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgIHRvdGFsU2l6ZSArPSBmaWxlLnNpemU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybih0b3RhbFNpemUpO1xuICAgIH07XG4gICAgJC5oYW5kbGVEcm9wRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgb25Ecm9wKGUpO1xuICAgIH07XG4gICAgJC5oYW5kbGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBhcHBlbmRGaWxlc0Zyb21GaWxlTGlzdChlLnRhcmdldC5maWxlcywgZSk7XG4gICAgICBlLnRhcmdldC52YWx1ZSA9ICcnO1xuICAgIH07XG4gICAgJC51cGRhdGVRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KXtcbiAgICAgICAgJC5vcHRzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgfTtcblxuICAgIHJldHVybih0aGlzKTtcbiAgfTtcblxuXG4gIC8vIE5vZGUuanMtc3R5bGUgZXhwb3J0IGZvciBOb2RlIGFuZCBDb21wb25lbnRcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlc3VtYWJsZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC9yZXF1aXJlanM6IERlZmluZSB0aGUgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gUmVzdW1hYmxlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXI6IEV4cG9zZSB0byB3aW5kb3dcbiAgICB3aW5kb3cuUmVzdW1hYmxlID0gUmVzdW1hYmxlO1xuICB9XG5cbn0pKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/resumablejs/resumable.js\n");

/***/ }),

/***/ "./src/lib/components/Upload.react.js":
/*!********************************************!*\
  !*** ./src/lib/components/Upload.react.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _resumablejs = __webpack_require__(/*! resumablejs */ \"./node_modules/resumablejs/resumable.js\");\n\nvar _resumablejs2 = _interopRequireDefault(_resumablejs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Upload = function (_Component) {\n    _inherits(Upload, _Component);\n\n    function Upload(props) {\n        _classCallCheck(this, Upload);\n\n        var _this = _possibleConstructorReturn(this, (Upload.__proto__ || Object.getPrototypeOf(Upload)).call(this, props));\n\n        _this.state = {\n            progressBar: 0,\n            messageStatus: '',\n            fileList: { files: [] },\n            isUploading: false,\n            isHovered: false,\n            isComplete: false\n        };\n        _this.toggleHovered = _this.toggleHovered.bind(_this);\n        _this.resumable = null;\n        return _this;\n    }\n\n    _createClass(Upload, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            var _this2 = this;\n\n            var ResumableField = new _resumablejs2.default({\n                target: this.props.service,\n                query: {},\n                fileType: this.props.filetypes,\n                maxFiles: this.props.maxFiles,\n                maxFileSize: this.props.maxFileSize,\n                fileTypeErrorCallback: function fileTypeErrorCallback() {\n                    _this2.setState({\n                        messageStatus: 'Invalid file type!'\n                    });\n                },\n                testMethod: 'post',\n                testChunks: false,\n                headers: {},\n                chunkSize: this.props.chunkSize,\n                simultaneousUploads: this.props.simultaneousUploads,\n                forceChunkSize: false\n            });\n\n            ResumableField.assignBrowse(this.uploader);\n\n            //Enable or Disable DragAnd Drop\n            if (this.props.disableDragAndDrop === false) {\n                ResumableField.assignDrop(this.dropZone);\n            }\n\n            ResumableField.on('fileAdded', function (file) {\n                _this2.setState({\n                    messageStatus: _this2.props.fileAddedMessage || ' Starting upload! of ' + file.fileName,\n                    isComplete: false\n                });\n\n                if (typeof _this2.props.onFileAdded === 'function') {\n                    _this2.props.onFileAdded(file, _this2.resumable);\n                } else {\n                    ResumableField.upload();\n                }\n            });\n\n            ResumableField.on('fileSuccess', function (file, fileServer) {\n\n                if (_this2.props.fileNameServer) {\n                    var objectServer = JSON.parse(fileServer);\n                    file.fileName = objectServer[_this2.props.fileNameServer];\n                } else {\n                    file.fileName = fileServer;\n                }\n                var currentFiles = _this2.state.fileList.files;\n                currentFiles.push(file);\n\n                var fileNames = _this2.props.fileNames;\n                fileNames.push(file.fileName);\n\n                if (_this2.props.setProps) {\n                    _this2.props.setProps({\n                        fileNames: fileNames\n                    });\n                }\n                _this2.setState({\n                    fileList: { files: currentFiles },\n                    isComplete: true,\n                    messageStatus: _this2.props.completedMessage + file.fileName || fileServer\n                }, function () {\n                    if (typeof _this2.props.onFileSuccess === 'function') {\n                        _this2.props.onFileSuccess(file, fileServer);\n                    }\n                });\n            });\n\n            ResumableField.on('progress', function () {\n\n                _this2.setState({\n                    isUploading: ResumableField.isUploading()\n                });\n\n                if (ResumableField.progress() * 100 < 100) {\n                    _this2.setState({\n                        messageStatus: parseInt(ResumableField.progress() * 100, 10) + '%',\n                        progressBar: ResumableField.progress() * 100\n                    });\n                } else {\n                    setTimeout(function () {\n                        _this2.setState({\n                            progressBar: 0\n                        });\n                    }, 1000);\n                }\n            });\n\n            ResumableField.on('fileError', function (file, errorCount) {\n                _this2.props.onUploadErrorCallback(file, errorCount);\n            });\n\n            this.resumable = ResumableField;\n        }\n    }, {\n        key: 'toggleHovered',\n        value: function toggleHovered() {\n            this.setState({\n                isHovered: !this.state.isHovered\n            });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var _this3 = this;\n\n            var getStyle = function getStyle() {\n                if (_this3.state.isComplete) {\n                    return _this3.props.completeStyle;\n                } else if (_this3.state.isHovered || _this3.state.isUploading) {\n                    return _this3.props.activeStyle;\n                } else {\n                    return _this3.props.defaultStyle;\n                }\n            };\n\n            var getClass = function getClass() {\n                if (_this3.props.disabledInput) {\n                    return _this3.props.disableClass;\n                } else if (_this3.state.isHovered) {\n                    return _this3.props.hoveredClass;\n                } else if (_this3.state.isUploading) {\n                    return _this3.props.uploadingClass;\n                } else if (_this3.state.isComplete) {\n                    return _this3.props.completeClass;\n                } else {\n                    return _this3.props.className;\n                }\n            };\n\n            return _react2.default.createElement(\n                'div',\n                {\n                    id: this.props.id,\n                    className: getClass(),\n                    ref: function ref(node) {\n                        return _this3.dropZone = node;\n                    }\n                },\n                _react2.default.createElement(\n                    'label',\n                    {\n                        style: getStyle(),\n                        onMouseEnter: this.toggleHovered,\n                        onMouseLeave: this.toggleHovered\n                    },\n                    this.state.messageStatus == '' ? this.props.children : this.state.messageStatus,\n                    _react2.default.createElement('input', {\n                        ref: function ref(node) {\n                            return _this3.uploader = node;\n                        },\n                        type: 'file',\n                        className: 'btn',\n                        name: this.props.id + '-upload',\n                        accept: this.props.fileAccept || '*',\n                        disabled: this.props.disableInput || false,\n                        style: { 'opacity': '0',\n                            'width': '0.1px%',\n                            'height': '0.1px%',\n                            'position': 'absolute',\n                            'overflow': 'hidden',\n                            'z-index': '-1' }\n                    })\n                ),\n                _react2.default.createElement(\n                    'div',\n                    {\n                        className: 'progress',\n                        style: { display: this.state.progressBar === 0 ? 'none' : 'block' }\n                    },\n                    _react2.default.createElement('div', {\n                        className: 'progress-bar',\n                        style: { width: this.state.progressBar + '%', height: '100%' }\n                    })\n                )\n            );\n        }\n    }]);\n\n    return Upload;\n}(_react.Component);\n\nexports.default = Upload;\n\n\nUpload.defaultProps = {\n    maxFiles: 1,\n    maxFileSize: 1024 * 1024 * 10,\n    chunkSize: 1024 * 1024,\n    simultaneuosUploads: 1,\n    service: '/upload',\n    className: 'resumable-default',\n    hoveredClass: 'resumable-hovered',\n    completeClass: 'resumable-complete',\n    disabledClass: 'resumable-disabled',\n    uploadingClass: 'resumable-uploading',\n    defaultStyle: {},\n    activeStyle: {},\n    completeStyle: {},\n    completedMessage: 'Complete! ',\n    fileNames: [],\n    filetypes: undefined,\n    disableDragAndDrop: false\n};\n\nUpload.propTypes = {\n\n    /**\r\n    * The ID of this component, used to identify dash components\r\n    * in callbacks. The ID needs to be unique across all of the\r\n    * components in an app.\r\n    */\n    id: _propTypes2.default.string,\n\n    /**\r\n    * The children of this component.\r\n    */\n    children: _propTypes2.default.node,\n\n    /**\r\n     * Maximum number of files that can be uploaded in one session\r\n     */\n    maxFiles: _propTypes2.default.number,\n\n    /**\r\n     * Maximum size per file in bytes.\r\n     */\n    maxFileSize: _propTypes2.default.number,\n\n    /**\r\n     * Size of file chunks to send to server.\r\n     */\n    chunkSize: _propTypes2.default.number,\n\n    /**\r\n     * Number of simultaneous uploads to select\r\n     */\n    simultaneousUploads: _propTypes2.default.number,\n\n    /**\r\n     * The service to send the files to\r\n     */\n    service: _propTypes2.default.string,\n\n    /**\r\n     * Class to add to the upload component by default\r\n     */\n    className: _propTypes2.default.string,\n\n    /**\r\n     * Class to add to the upload component when it is hovered\r\n     */\n    hoveredClass: _propTypes2.default.string,\n\n    /**\r\n     * Class to add to the upload component when it is disabled\r\n     */\n    disabledClass: _propTypes2.default.string,\n\n    /**\r\n     * Class to add to the upload component when it is complete\r\n     */\n    completeClass: _propTypes2.default.string,\n\n    /**\r\n     * Class to add to the upload component when it is uploading\r\n     */\n    uploadingClass: _propTypes2.default.string,\n\n    /**\r\n     * Style attributes to add to the upload component\r\n     */\n    defaultStyle: _propTypes2.default.object,\n\n    /**\r\n     * Style when upload component is hovered over\r\n     */\n    activeStyle: _propTypes2.default.object,\n\n    /**\r\n     * Style when upload is completed (upload finished)\r\n     */\n    completeStyle: _propTypes2.default.object,\n\n    /**\r\n     * Message to display when upload completed\r\n     */\n    completedMessage: _propTypes2.default.string,\n\n    /**\r\n     * The names of the files uploaded\r\n     */\n    fileNames: _propTypes2.default.arrayOf(_propTypes2.default.string),\n\n    /**\r\n     * List of allowed file types, e.g. ['jpg', 'png']\r\n     */\n    filetypes: _propTypes2.default.arrayOf(_propTypes2.default.string),\n\n    /**\r\n     * Whether or not to allow file drag and drop\r\n     */\n    disableDragAndDrop: _propTypes2.default.bool,\n\n    /**\r\n     * Dash-assigned callback that should be called whenever any of the\r\n     * properties change\r\n     */\n    setProps: _propTypes2.default.func\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9zcmMvbGliL2NvbXBvbmVudHMvVXBsb2FkLnJlYWN0LmpzPzQ4MjEiXSwibmFtZXMiOlsiVXBsb2FkIiwicHJvcHMiLCJzdGF0ZSIsInByb2dyZXNzQmFyIiwibWVzc2FnZVN0YXR1cyIsImZpbGVMaXN0IiwiZmlsZXMiLCJpc1VwbG9hZGluZyIsImlzSG92ZXJlZCIsImlzQ29tcGxldGUiLCJ0b2dnbGVIb3ZlcmVkIiwiYmluZCIsInJlc3VtYWJsZSIsIlJlc3VtYWJsZUZpZWxkIiwiUmVzdW1hYmxlanMiLCJ0YXJnZXQiLCJzZXJ2aWNlIiwicXVlcnkiLCJmaWxlVHlwZSIsImZpbGV0eXBlcyIsIm1heEZpbGVzIiwibWF4RmlsZVNpemUiLCJmaWxlVHlwZUVycm9yQ2FsbGJhY2siLCJzZXRTdGF0ZSIsInRlc3RNZXRob2QiLCJ0ZXN0Q2h1bmtzIiwiaGVhZGVycyIsImNodW5rU2l6ZSIsInNpbXVsdGFuZW91c1VwbG9hZHMiLCJmb3JjZUNodW5rU2l6ZSIsImFzc2lnbkJyb3dzZSIsInVwbG9hZGVyIiwiZGlzYWJsZURyYWdBbmREcm9wIiwiYXNzaWduRHJvcCIsImRyb3Bab25lIiwib24iLCJmaWxlIiwiZmlsZUFkZGVkTWVzc2FnZSIsImZpbGVOYW1lIiwib25GaWxlQWRkZWQiLCJ1cGxvYWQiLCJmaWxlU2VydmVyIiwiZmlsZU5hbWVTZXJ2ZXIiLCJvYmplY3RTZXJ2ZXIiLCJKU09OIiwicGFyc2UiLCJjdXJyZW50RmlsZXMiLCJwdXNoIiwiZmlsZU5hbWVzIiwic2V0UHJvcHMiLCJjb21wbGV0ZWRNZXNzYWdlIiwib25GaWxlU3VjY2VzcyIsInByb2dyZXNzIiwicGFyc2VJbnQiLCJzZXRUaW1lb3V0IiwiZXJyb3JDb3VudCIsIm9uVXBsb2FkRXJyb3JDYWxsYmFjayIsImdldFN0eWxlIiwiY29tcGxldGVTdHlsZSIsImFjdGl2ZVN0eWxlIiwiZGVmYXVsdFN0eWxlIiwiZ2V0Q2xhc3MiLCJkaXNhYmxlZElucHV0IiwiZGlzYWJsZUNsYXNzIiwiaG92ZXJlZENsYXNzIiwidXBsb2FkaW5nQ2xhc3MiLCJjb21wbGV0ZUNsYXNzIiwiY2xhc3NOYW1lIiwiaWQiLCJub2RlIiwiY2hpbGRyZW4iLCJmaWxlQWNjZXB0IiwiZGlzYWJsZUlucHV0IiwiZGlzcGxheSIsIndpZHRoIiwiaGVpZ2h0IiwiQ29tcG9uZW50IiwiZGVmYXVsdFByb3BzIiwic2ltdWx0YW5ldW9zVXBsb2FkcyIsImRpc2FibGVkQ2xhc3MiLCJ1bmRlZmluZWQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJudW1iZXIiLCJvYmplY3QiLCJhcnJheU9mIiwiYm9vbCIsImZ1bmMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFcUJBLE07OztBQUVqQixvQkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUFBLG9IQUNUQSxLQURTOztBQUVmLGNBQUtDLEtBQUwsR0FBYTtBQUNUQyx5QkFBYSxDQURKO0FBRVRDLDJCQUFlLEVBRk47QUFHVEMsc0JBQVUsRUFBQ0MsT0FBTyxFQUFSLEVBSEQ7QUFJVEMseUJBQWEsS0FKSjtBQUtUQyx1QkFBVyxLQUxGO0FBTVRDLHdCQUFZO0FBTkgsU0FBYjtBQVFBLGNBQUtDLGFBQUwsR0FBcUIsTUFBS0EsYUFBTCxDQUFtQkMsSUFBbkIsT0FBckI7QUFDQSxjQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBWGU7QUFZbEI7Ozs7NENBRW1CO0FBQUE7O0FBRWhCLGdCQUFNQyxpQkFBaUIsSUFBSUMscUJBQUosQ0FBZ0I7QUFDbkNDLHdCQUFRLEtBQUtkLEtBQUwsQ0FBV2UsT0FEZ0I7QUFFbkNDLHVCQUFPLEVBRjRCO0FBR25DQywwQkFBVSxLQUFLakIsS0FBTCxDQUFXa0IsU0FIYztBQUluQ0MsMEJBQVUsS0FBS25CLEtBQUwsQ0FBV21CLFFBSmM7QUFLbkNDLDZCQUFhLEtBQUtwQixLQUFMLENBQVdvQixXQUxXO0FBTW5DQyx1Q0FBdUIsaUNBQU07QUFDekIsMkJBQUtDLFFBQUwsQ0FBYztBQUNWbkIsdUNBQWU7QUFETCxxQkFBZDtBQUdILGlCQVZrQztBQVduQ29CLDRCQUFZLE1BWHVCO0FBWW5DQyw0QkFBWSxLQVp1QjtBQWFuQ0MseUJBQVMsRUFiMEI7QUFjbkNDLDJCQUFXLEtBQUsxQixLQUFMLENBQVcwQixTQWRhO0FBZW5DQyxxQ0FBcUIsS0FBSzNCLEtBQUwsQ0FBVzJCLG1CQWZHO0FBZ0JuQ0MsZ0NBQWdCO0FBaEJtQixhQUFoQixDQUF2Qjs7QUFtQkFoQiwyQkFBZWlCLFlBQWYsQ0FBNEIsS0FBS0MsUUFBakM7O0FBRUE7QUFDQSxnQkFBSSxLQUFLOUIsS0FBTCxDQUFXK0Isa0JBQVgsS0FBa0MsS0FBdEMsRUFBNkM7QUFDekNuQiwrQkFBZW9CLFVBQWYsQ0FBMEIsS0FBS0MsUUFBL0I7QUFDSDs7QUFFRHJCLDJCQUFlc0IsRUFBZixDQUFrQixXQUFsQixFQUErQixVQUFDQyxJQUFELEVBQVU7QUFDckMsdUJBQUtiLFFBQUwsQ0FBYztBQUNWbkIsbUNBQWUsT0FBS0gsS0FBTCxDQUFXb0MsZ0JBQVgsSUFBK0IsMEJBQTBCRCxLQUFLRSxRQURuRTtBQUVWN0IsZ0NBQVk7QUFGRixpQkFBZDs7QUFLQyxvQkFBSSxPQUFPLE9BQUtSLEtBQUwsQ0FBV3NDLFdBQWxCLEtBQWtDLFVBQXRDLEVBQWtEO0FBQzlDLDJCQUFLdEMsS0FBTCxDQUFXc0MsV0FBWCxDQUF1QkgsSUFBdkIsRUFBNkIsT0FBS3hCLFNBQWxDO0FBQ0gsaUJBRkQsTUFFTztBQUNIQyxtQ0FBZTJCLE1BQWY7QUFDSDtBQUNMLGFBWEQ7O0FBYUEzQiwyQkFBZXNCLEVBQWYsQ0FBa0IsYUFBbEIsRUFBaUMsVUFBQ0MsSUFBRCxFQUFPSyxVQUFQLEVBQXNCOztBQUVuRCxvQkFBSSxPQUFLeEMsS0FBTCxDQUFXeUMsY0FBZixFQUErQjtBQUMzQix3QkFBSUMsZUFBZUMsS0FBS0MsS0FBTCxDQUFXSixVQUFYLENBQW5CO0FBQ0FMLHlCQUFLRSxRQUFMLEdBQWdCSyxhQUFhLE9BQUsxQyxLQUFMLENBQVd5QyxjQUF4QixDQUFoQjtBQUNILGlCQUhELE1BR087QUFDSE4seUJBQUtFLFFBQUwsR0FBZ0JHLFVBQWhCO0FBQ0g7QUFDRCxvQkFBSUssZUFBZSxPQUFLNUMsS0FBTCxDQUFXRyxRQUFYLENBQW9CQyxLQUF2QztBQUNBd0MsNkJBQWFDLElBQWIsQ0FBa0JYLElBQWxCOztBQUVBLG9CQUFJWSxZQUFZLE9BQUsvQyxLQUFMLENBQVcrQyxTQUEzQjtBQUNBQSwwQkFBVUQsSUFBVixDQUFlWCxLQUFLRSxRQUFwQjs7QUFFQSxvQkFBSSxPQUFLckMsS0FBTCxDQUFXZ0QsUUFBZixFQUF5QjtBQUNyQiwyQkFBS2hELEtBQUwsQ0FBV2dELFFBQVgsQ0FBb0I7QUFDZEQsbUNBQVdBO0FBREcscUJBQXBCO0FBR0g7QUFDRCx1QkFBS3pCLFFBQUwsQ0FBYztBQUNWbEIsOEJBQVUsRUFBQ0MsT0FBT3dDLFlBQVIsRUFEQTtBQUVWckMsZ0NBQVksSUFGRjtBQUdWTCxtQ0FBZSxPQUFLSCxLQUFMLENBQVdpRCxnQkFBWCxHQUE4QmQsS0FBS0UsUUFBbkMsSUFBK0NHO0FBSHBELGlCQUFkLEVBSUcsWUFBTTtBQUNMLHdCQUFJLE9BQU8sT0FBS3hDLEtBQUwsQ0FBV2tELGFBQWxCLEtBQW9DLFVBQXhDLEVBQW9EO0FBQ2hELCtCQUFLbEQsS0FBTCxDQUFXa0QsYUFBWCxDQUF5QmYsSUFBekIsRUFBK0JLLFVBQS9CO0FBQ0g7QUFDSixpQkFSRDtBQVNILGFBNUJEOztBQThCQTVCLDJCQUFlc0IsRUFBZixDQUFrQixVQUFsQixFQUE4QixZQUFNOztBQUdoQyx1QkFBS1osUUFBTCxDQUFjO0FBQ1ZoQixpQ0FBYU0sZUFBZU4sV0FBZjtBQURILGlCQUFkOztBQUlBLG9CQUFLTSxlQUFldUMsUUFBZixLQUE0QixHQUE3QixHQUFvQyxHQUF4QyxFQUE2QztBQUN6QywyQkFBSzdCLFFBQUwsQ0FBYztBQUNWbkIsdUNBQWVpRCxTQUFTeEMsZUFBZXVDLFFBQWYsS0FBNEIsR0FBckMsRUFBMEMsRUFBMUMsSUFBZ0QsR0FEckQ7QUFFVmpELHFDQUFhVSxlQUFldUMsUUFBZixLQUE0QjtBQUYvQixxQkFBZDtBQUlILGlCQUxELE1BS087QUFDSEUsK0JBQVcsWUFBTTtBQUNiLCtCQUFLL0IsUUFBTCxDQUFjO0FBQ1ZwQix5Q0FBYTtBQURILHlCQUFkO0FBR0gscUJBSkQsRUFJRyxJQUpIO0FBS0g7QUFFSixhQXBCRDs7QUFzQkFVLDJCQUFlc0IsRUFBZixDQUFrQixXQUFsQixFQUErQixVQUFDQyxJQUFELEVBQU9tQixVQUFQLEVBQXNCO0FBQ2pELHVCQUFLdEQsS0FBTCxDQUFXdUQscUJBQVgsQ0FBaUNwQixJQUFqQyxFQUF1Q21CLFVBQXZDO0FBQ0gsYUFGRDs7QUFJQSxpQkFBSzNDLFNBQUwsR0FBaUJDLGNBQWpCO0FBQ0g7Ozt3Q0FFZTtBQUNaLGlCQUFLVSxRQUFMLENBQWM7QUFDVmYsMkJBQVcsQ0FBQyxLQUFLTixLQUFMLENBQVdNO0FBRGIsYUFBZDtBQUdIOzs7aUNBRVE7QUFBQTs7QUFFTCxnQkFBSWlELFdBQVcsU0FBWEEsUUFBVyxHQUFNO0FBQ2pCLG9CQUFJLE9BQUt2RCxLQUFMLENBQVdPLFVBQWYsRUFBMkI7QUFDdkIsMkJBQU8sT0FBS1IsS0FBTCxDQUFXeUQsYUFBbEI7QUFDSCxpQkFGRCxNQUVPLElBQUksT0FBS3hELEtBQUwsQ0FBV00sU0FBWCxJQUF3QixPQUFLTixLQUFMLENBQVdLLFdBQXZDLEVBQW9EO0FBQ3ZELDJCQUFPLE9BQUtOLEtBQUwsQ0FBVzBELFdBQWxCO0FBQ0gsaUJBRk0sTUFFQTtBQUNILDJCQUFPLE9BQUsxRCxLQUFMLENBQVcyRCxZQUFsQjtBQUNIO0FBQ0osYUFSRDs7QUFVQSxnQkFBSUMsV0FBVyxTQUFYQSxRQUFXLEdBQU07QUFDakIsb0JBQUksT0FBSzVELEtBQUwsQ0FBVzZELGFBQWYsRUFBOEI7QUFDNUIsMkJBQU8sT0FBSzdELEtBQUwsQ0FBVzhELFlBQWxCO0FBQ0QsaUJBRkQsTUFFTyxJQUFJLE9BQUs3RCxLQUFMLENBQVdNLFNBQWYsRUFBMEI7QUFDL0IsMkJBQU8sT0FBS1AsS0FBTCxDQUFXK0QsWUFBbEI7QUFDRCxpQkFGTSxNQUVBLElBQUksT0FBSzlELEtBQUwsQ0FBV0ssV0FBZixFQUE0QjtBQUNqQywyQkFBTyxPQUFLTixLQUFMLENBQVdnRSxjQUFsQjtBQUNELGlCQUZNLE1BRUEsSUFBSSxPQUFLL0QsS0FBTCxDQUFXTyxVQUFmLEVBQTJCO0FBQ2hDLDJCQUFPLE9BQUtSLEtBQUwsQ0FBV2lFLGFBQWxCO0FBQ0QsaUJBRk0sTUFFQTtBQUNMLDJCQUFPLE9BQUtqRSxLQUFMLENBQVdrRSxTQUFsQjtBQUNEO0FBQ0osYUFaRDs7QUFjQSxtQkFDSTtBQUFBO0FBQUE7QUFDUix3QkFBSSxLQUFLbEUsS0FBTCxDQUFXbUUsRUFEUDtBQUVSLCtCQUFXUCxVQUZIO0FBR1IseUJBQUs7QUFBQSwrQkFBUSxPQUFLM0IsUUFBTCxHQUFnQm1DLElBQXhCO0FBQUE7QUFIRztBQUtJO0FBQUE7QUFBQTtBQUNYLCtCQUFPWixVQURJO0FBRVgsc0NBQWMsS0FBSy9DLGFBRlI7QUFHWCxzQ0FBYyxLQUFLQTtBQUhSO0FBS1YseUJBQUtSLEtBQUwsQ0FBV0UsYUFBWCxJQUE0QixFQUE1QixHQUFpQyxLQUFLSCxLQUFMLENBQVdxRSxRQUE1QyxHQUF1RCxLQUFLcEUsS0FBTCxDQUFXRSxhQUx4RDtBQU1JO0FBQ0ksNkJBQUs7QUFBQSxtQ0FBTyxPQUFLMkIsUUFBTCxHQUFnQnNDLElBQXZCO0FBQUEseUJBRFQ7QUFFSSw4QkFBSyxNQUZUO0FBR0ksbUNBQVUsS0FIZDtBQUlJLDhCQUFNLEtBQUtwRSxLQUFMLENBQVdtRSxFQUFYLEdBQWdCLFNBSjFCO0FBS0ksZ0NBQVEsS0FBS25FLEtBQUwsQ0FBV3NFLFVBQVgsSUFBeUIsR0FMckM7QUFNSSxrQ0FBVSxLQUFLdEUsS0FBTCxDQUFXdUUsWUFBWCxJQUEyQixLQU56QztBQU9JLCtCQUFPLEVBQUMsV0FBVyxHQUFaO0FBQ0MscUNBQVMsUUFEVjtBQUVDLHNDQUFVLFFBRlg7QUFHQyx3Q0FBWSxVQUhiO0FBSUMsd0NBQVksUUFKYjtBQUtDLHVDQUFXLElBTFo7QUFQWDtBQU5KLGlCQUxKO0FBMkJJO0FBQUE7QUFBQTtBQUNYLG1DQUFVLFVBREM7QUFFWCwrQkFBTyxFQUFDQyxTQUFTLEtBQUt2RSxLQUFMLENBQVdDLFdBQVgsS0FBMkIsQ0FBM0IsR0FBK0IsTUFBL0IsR0FBd0MsT0FBbEQ7QUFGSTtBQUlJO0FBQ2QsbUNBQVUsY0FESTtBQUVkLCtCQUFPLEVBQUN1RSxPQUFPLEtBQUt4RSxLQUFMLENBQVdDLFdBQVgsR0FBeUIsR0FBakMsRUFBc0N3RSxRQUFRLE1BQTlDO0FBRk87QUFKSjtBQTNCSixhQURKO0FBd0NIOzs7O0VBNUwrQkMsZ0I7O2tCQUFmNUUsTTs7O0FBK0xyQkEsT0FBTzZFLFlBQVAsR0FBc0I7QUFDbEJ6RCxjQUFVLENBRFE7QUFFbEJDLGlCQUFhLE9BQU8sSUFBUCxHQUFjLEVBRlQ7QUFHbEJNLGVBQVcsT0FBTyxJQUhBO0FBSWxCbUQseUJBQXFCLENBSkg7QUFLbEI5RCxhQUFTLFNBTFM7QUFNbEJtRCxlQUFXLG1CQU5PO0FBT2xCSCxrQkFBYyxtQkFQSTtBQVFsQkUsbUJBQWUsb0JBUkc7QUFTbEJhLG1CQUFlLG9CQVRHO0FBVWxCZCxvQkFBZ0IscUJBVkU7QUFXbEJMLGtCQUFjLEVBWEk7QUFZbEJELGlCQUFhLEVBWks7QUFhbEJELG1CQUFlLEVBYkc7QUFjbEJSLHNCQUFrQixZQWRBO0FBZWxCRixlQUFXLEVBZk87QUFnQmxCN0IsZUFBVzZELFNBaEJPO0FBaUJsQmhELHdCQUFvQjtBQWpCRixDQUF0Qjs7QUFvQkFoQyxPQUFPaUYsU0FBUCxHQUFtQjs7QUFFbEI7Ozs7O0FBS0FiLFFBQUljLG9CQUFVQyxNQVBJOztBQVNsQjs7O0FBR0FiLGNBQVVZLG9CQUFVYixJQVpGOztBQWNmOzs7QUFHQWpELGNBQVU4RCxvQkFBVUUsTUFqQkw7O0FBbUJmOzs7QUFHQS9ELGlCQUFhNkQsb0JBQVVFLE1BdEJSOztBQXdCZjs7O0FBR0F6RCxlQUFXdUQsb0JBQVVFLE1BM0JOOztBQTZCZjs7O0FBR0F4RCx5QkFBcUJzRCxvQkFBVUUsTUFoQ2hCOztBQWtDZjs7O0FBR0FwRSxhQUFTa0Usb0JBQVVDLE1BckNKOztBQXVDZjs7O0FBR0FoQixlQUFXZSxvQkFBVUMsTUExQ047O0FBNENmOzs7QUFHQW5CLGtCQUFja0Isb0JBQVVDLE1BL0NUOztBQWlEZjs7O0FBR0FKLG1CQUFlRyxvQkFBVUMsTUFwRFY7O0FBc0RmOzs7QUFHQWpCLG1CQUFlZ0Isb0JBQVVDLE1BekRWOztBQTJEZjs7O0FBR0FsQixvQkFBZ0JpQixvQkFBVUMsTUE5RFg7O0FBZ0VmOzs7QUFHQXZCLGtCQUFjc0Isb0JBQVVHLE1BbkVUOztBQXFFZjs7O0FBR0ExQixpQkFBYXVCLG9CQUFVRyxNQXhFUjs7QUEwRWhCOzs7QUFHQzNCLG1CQUFld0Isb0JBQVVHLE1BN0VWOztBQStFZjs7O0FBR0FuQyxzQkFBa0JnQyxvQkFBVUMsTUFsRmI7O0FBb0ZmOzs7QUFHQW5DLGVBQVdrQyxvQkFBVUksT0FBVixDQUFrQkosb0JBQVVDLE1BQTVCLENBdkZJOztBQXlGZjs7O0FBR0FoRSxlQUFXK0Qsb0JBQVVJLE9BQVYsQ0FBa0JKLG9CQUFVQyxNQUE1QixDQTVGSTs7QUE4RmY7OztBQUdBbkQsd0JBQW9Ca0Qsb0JBQVVLLElBakdmOztBQW1HZjs7OztBQUlBdEMsY0FBVWlDLG9CQUFVTTs7QUF2R0wsQ0FBbkIiLCJmaWxlIjoiLi9zcmMvbGliL2NvbXBvbmVudHMvVXBsb2FkLnJlYWN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IFJlc3VtYWJsZWpzIGZyb20gJ3Jlc3VtYWJsZWpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwbG9hZCBleHRlbmRzIENvbXBvbmVudCB7XHJcblx0XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBwcm9ncmVzc0JhcjogMCxcclxuICAgICAgICAgICAgbWVzc2FnZVN0YXR1czogJycsXHJcbiAgICAgICAgICAgIGZpbGVMaXN0OiB7ZmlsZXM6IFtdfSxcclxuICAgICAgICAgICAgaXNVcGxvYWRpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICBpc0hvdmVyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBpc0NvbXBsZXRlOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50b2dnbGVIb3ZlcmVkID0gdGhpcy50b2dnbGVIb3ZlcmVkLmJpbmQodGhpcylcclxuICAgICAgICB0aGlzLnJlc3VtYWJsZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IFJlc3VtYWJsZUZpZWxkID0gbmV3IFJlc3VtYWJsZWpzKHtcclxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnByb3BzLnNlcnZpY2UsXHJcbiAgICAgICAgICAgIHF1ZXJ5OiB7fSxcclxuICAgICAgICAgICAgZmlsZVR5cGU6IHRoaXMucHJvcHMuZmlsZXR5cGVzLFxyXG4gICAgICAgICAgICBtYXhGaWxlczogdGhpcy5wcm9wcy5tYXhGaWxlcyxcclxuICAgICAgICAgICAgbWF4RmlsZVNpemU6IHRoaXMucHJvcHMubWF4RmlsZVNpemUsXHJcbiAgICAgICAgICAgIGZpbGVUeXBlRXJyb3JDYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVN0YXR1czogJ0ludmFsaWQgZmlsZSB0eXBlISdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0ZXN0TWV0aG9kOiAncG9zdCcsXHJcbiAgICAgICAgICAgIHRlc3RDaHVua3M6IGZhbHNlLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgICAgY2h1bmtTaXplOiB0aGlzLnByb3BzLmNodW5rU2l6ZSxcclxuICAgICAgICAgICAgc2ltdWx0YW5lb3VzVXBsb2FkczogdGhpcy5wcm9wcy5zaW11bHRhbmVvdXNVcGxvYWRzLFxyXG4gICAgICAgICAgICBmb3JjZUNodW5rU2l6ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgUmVzdW1hYmxlRmllbGQuYXNzaWduQnJvd3NlKHRoaXMudXBsb2FkZXIpO1xyXG5cclxuICAgICAgICAvL0VuYWJsZSBvciBEaXNhYmxlIERyYWdBbmQgRHJvcFxyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVEcmFnQW5kRHJvcCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgUmVzdW1hYmxlRmllbGQuYXNzaWduRHJvcCh0aGlzLmRyb3Bab25lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFJlc3VtYWJsZUZpZWxkLm9uKCdmaWxlQWRkZWQnLCAoZmlsZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VTdGF0dXM6IHRoaXMucHJvcHMuZmlsZUFkZGVkTWVzc2FnZSB8fCAnIFN0YXJ0aW5nIHVwbG9hZCEgb2YgJyArIGZpbGUuZmlsZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25GaWxlQWRkZWQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRmlsZUFkZGVkKGZpbGUsIHRoaXMucmVzdW1hYmxlKTtcclxuICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgUmVzdW1hYmxlRmllbGQudXBsb2FkKCk7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIFJlc3VtYWJsZUZpZWxkLm9uKCdmaWxlU3VjY2VzcycsIChmaWxlLCBmaWxlU2VydmVyKSA9PiB7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5maWxlTmFtZVNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgbGV0IG9iamVjdFNlcnZlciA9IEpTT04ucGFyc2UoZmlsZVNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICBmaWxlLmZpbGVOYW1lID0gb2JqZWN0U2VydmVyW3RoaXMucHJvcHMuZmlsZU5hbWVTZXJ2ZXJdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmlsZS5maWxlTmFtZSA9IGZpbGVTZXJ2ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRGaWxlcyA9IHRoaXMuc3RhdGUuZmlsZUxpc3QuZmlsZXM7XHJcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlcy5wdXNoKGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGZpbGVOYW1lcyA9IHRoaXMucHJvcHMuZmlsZU5hbWVzXHJcbiAgICAgICAgICAgIGZpbGVOYW1lcy5wdXNoKGZpbGUuZmlsZU5hbWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2V0UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc2V0UHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWVzOiBmaWxlTmFtZXNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgZmlsZUxpc3Q6IHtmaWxlczogY3VycmVudEZpbGVzfSxcclxuICAgICAgICAgICAgICAgIGlzQ29tcGxldGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlU3RhdHVzOiB0aGlzLnByb3BzLmNvbXBsZXRlZE1lc3NhZ2UgKyBmaWxlLmZpbGVOYW1lIHx8IGZpbGVTZXJ2ZXJcclxuICAgICAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uRmlsZVN1Y2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRmlsZVN1Y2Nlc3MoZmlsZSwgZmlsZVNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBSZXN1bWFibGVGaWVsZC5vbigncHJvZ3Jlc3MnLCAoKSA9PiB7XHJcblxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBpc1VwbG9hZGluZzogUmVzdW1hYmxlRmllbGQuaXNVcGxvYWRpbmcoKVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICgoUmVzdW1hYmxlRmllbGQucHJvZ3Jlc3MoKSAqIDEwMCkgPCAxMDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VTdGF0dXM6IHBhcnNlSW50KFJlc3VtYWJsZUZpZWxkLnByb2dyZXNzKCkgKiAxMDAsIDEwKSArICclJyxcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0JhcjogUmVzdW1hYmxlRmllbGQucHJvZ3Jlc3MoKSAqIDEwMFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXI6IDBcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIFJlc3VtYWJsZUZpZWxkLm9uKCdmaWxlRXJyb3InLCAoZmlsZSwgZXJyb3JDb3VudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uVXBsb2FkRXJyb3JDYWxsYmFjayhmaWxlLCBlcnJvckNvdW50KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXN1bWFibGUgPSBSZXN1bWFibGVGaWVsZDtcclxuICAgIH1cclxuXHJcbiAgICB0b2dnbGVIb3ZlcmVkKCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBpc0hvdmVyZWQ6ICF0aGlzLnN0YXRlLmlzSG92ZXJlZFxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG5cclxuICAgICAgICBsZXQgZ2V0U3R5bGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmlzQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNvbXBsZXRlU3R5bGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pc0hvdmVyZWQgfHwgdGhpcy5zdGF0ZS5pc1VwbG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuYWN0aXZlU3R5bGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5kZWZhdWx0U3R5bGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBnZXRDbGFzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWRJbnB1dCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmRpc2FibGVDbGFzcztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmlzSG92ZXJlZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmhvdmVyZWRDbGFzcztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmlzVXBsb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMudXBsb2FkaW5nQ2xhc3M7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY29tcGxldGVDbGFzcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jbGFzc05hbWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuKFxyXG4gICAgICAgICAgICA8ZGl2IFxyXG5cdFx0XHRcdGlkPXt0aGlzLnByb3BzLmlkfSBcclxuXHRcdFx0XHRjbGFzc05hbWU9e2dldENsYXNzKCl9IFxyXG5cdFx0XHRcdHJlZj17bm9kZSA9PiB0aGlzLmRyb3Bab25lID0gbm9kZX1cclxuXHRcdFx0PlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsIFxyXG5cdFx0XHRcdFx0c3R5bGU9e2dldFN0eWxlKCl9IFxyXG5cdFx0XHRcdFx0b25Nb3VzZUVudGVyPXt0aGlzLnRvZ2dsZUhvdmVyZWR9IFxyXG5cdFx0XHRcdFx0b25Nb3VzZUxlYXZlPXt0aGlzLnRvZ2dsZUhvdmVyZWR9XHJcblx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0e3RoaXMuc3RhdGUubWVzc2FnZVN0YXR1cyA9PSAnJyA/IHRoaXMucHJvcHMuY2hpbGRyZW4gOiB0aGlzLnN0YXRlLm1lc3NhZ2VTdGF0dXN9XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17bm9kZT0+IHRoaXMudXBsb2FkZXIgPSBub2RlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiZmlsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT0nYnRuJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXt0aGlzLnByb3BzLmlkICsgJy11cGxvYWQnfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQ9e3RoaXMucHJvcHMuZmlsZUFjY2VwdCB8fCAnKid9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXt0aGlzLnByb3BzLmRpc2FibGVJbnB1dCB8fCBmYWxzZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3snb3BhY2l0eSc6ICcwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOiAnMC4xcHglJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJzAuMXB4JScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnei1pbmRleCc6ICctMSd9fVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuXHRcdFx0XHRcdDwvaW5wdXQ+XHJcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBcclxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cInByb2dyZXNzXCIgXHJcblx0XHRcdFx0XHRzdHlsZT17e2Rpc3BsYXk6IHRoaXMuc3RhdGUucHJvZ3Jlc3NCYXIgPT09IDAgPyAnbm9uZScgOiAnYmxvY2snfX1cclxuXHRcdFx0XHQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBcclxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwicHJvZ3Jlc3MtYmFyXCIgXHJcblx0XHRcdFx0XHRcdHN0eWxlPXt7d2lkdGg6IHRoaXMuc3RhdGUucHJvZ3Jlc3NCYXIgKyAnJScsIGhlaWdodDogJzEwMCUnfX1cclxuXHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuVXBsb2FkLmRlZmF1bHRQcm9wcyA9IHtcclxuICAgIG1heEZpbGVzOiAxLFxyXG4gICAgbWF4RmlsZVNpemU6IDEwMjQgKiAxMDI0ICogMTAsXHJcbiAgICBjaHVua1NpemU6IDEwMjQgKiAxMDI0LFxyXG4gICAgc2ltdWx0YW5ldW9zVXBsb2FkczogMSxcclxuICAgIHNlcnZpY2U6ICcvdXBsb2FkJyxcclxuICAgIGNsYXNzTmFtZTogJ3Jlc3VtYWJsZS1kZWZhdWx0JyxcclxuICAgIGhvdmVyZWRDbGFzczogJ3Jlc3VtYWJsZS1ob3ZlcmVkJyxcclxuICAgIGNvbXBsZXRlQ2xhc3M6ICdyZXN1bWFibGUtY29tcGxldGUnLFxyXG4gICAgZGlzYWJsZWRDbGFzczogJ3Jlc3VtYWJsZS1kaXNhYmxlZCcsXHJcbiAgICB1cGxvYWRpbmdDbGFzczogJ3Jlc3VtYWJsZS11cGxvYWRpbmcnLFxyXG4gICAgZGVmYXVsdFN0eWxlOiB7fSxcclxuICAgIGFjdGl2ZVN0eWxlOiB7fSxcclxuICAgIGNvbXBsZXRlU3R5bGU6IHt9LFxyXG4gICAgY29tcGxldGVkTWVzc2FnZTogJ0NvbXBsZXRlISAnLFxyXG4gICAgZmlsZU5hbWVzOiBbXSxcclxuICAgIGZpbGV0eXBlczogdW5kZWZpbmVkLFxyXG4gICAgZGlzYWJsZURyYWdBbmREcm9wOiBmYWxzZVxyXG59O1xyXG5cclxuVXBsb2FkLnByb3BUeXBlcyA9IHtcclxuXHRcclxuXHQvKipcclxuXHQqIFRoZSBJRCBvZiB0aGlzIGNvbXBvbmVudCwgdXNlZCB0byBpZGVudGlmeSBkYXNoIGNvbXBvbmVudHNcclxuXHQqIGluIGNhbGxiYWNrcy4gVGhlIElEIG5lZWRzIHRvIGJlIHVuaXF1ZSBhY3Jvc3MgYWxsIG9mIHRoZVxyXG5cdCogY29tcG9uZW50cyBpbiBhbiBhcHAuXHJcblx0Ki9cclxuXHRpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuXHJcblx0LyoqXHJcblx0KiBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQuXHJcblx0Ki9cclxuXHRjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXHJcblx0XHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGZpbGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIGluIG9uZSBzZXNzaW9uXHJcbiAgICAgKi9cclxuICAgIG1heEZpbGVzOiBQcm9wVHlwZXMubnVtYmVyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSBzaXplIHBlciBmaWxlIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBtYXhGaWxlU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpemUgb2YgZmlsZSBjaHVua3MgdG8gc2VuZCB0byBzZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIGNodW5rU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIE51bWJlciBvZiBzaW11bHRhbmVvdXMgdXBsb2FkcyB0byBzZWxlY3RcclxuICAgICAqL1xyXG4gICAgc2ltdWx0YW5lb3VzVXBsb2FkczogUHJvcFR5cGVzLm51bWJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXJ2aWNlIHRvIHNlbmQgdGhlIGZpbGVzIHRvXHJcbiAgICAgKi9cclxuICAgIHNlcnZpY2U6IFByb3BUeXBlcy5zdHJpbmcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyB0byBhZGQgdG8gdGhlIHVwbG9hZCBjb21wb25lbnQgYnkgZGVmYXVsdFxyXG4gICAgICovXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyB0byBhZGQgdG8gdGhlIHVwbG9hZCBjb21wb25lbnQgd2hlbiBpdCBpcyBob3ZlcmVkXHJcbiAgICAgKi9cclxuICAgIGhvdmVyZWRDbGFzczogUHJvcFR5cGVzLnN0cmluZyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYXNzIHRvIGFkZCB0byB0aGUgdXBsb2FkIGNvbXBvbmVudCB3aGVuIGl0IGlzIGRpc2FibGVkXHJcbiAgICAgKi9cclxuICAgIGRpc2FibGVkQ2xhc3M6IFByb3BUeXBlcy5zdHJpbmcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyB0byBhZGQgdG8gdGhlIHVwbG9hZCBjb21wb25lbnQgd2hlbiBpdCBpcyBjb21wbGV0ZVxyXG4gICAgICovXHJcbiAgICBjb21wbGV0ZUNsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhc3MgdG8gYWRkIHRvIHRoZSB1cGxvYWQgY29tcG9uZW50IHdoZW4gaXQgaXMgdXBsb2FkaW5nXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZGluZ0NsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3R5bGUgYXR0cmlidXRlcyB0byBhZGQgdG8gdGhlIHVwbG9hZCBjb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdFN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3R5bGUgd2hlbiB1cGxvYWQgY29tcG9uZW50IGlzIGhvdmVyZWQgb3ZlclxyXG4gICAgICovXHJcbiAgICBhY3RpdmVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcclxuXHJcbiAgIC8qKlxyXG4gICAgKiBTdHlsZSB3aGVuIHVwbG9hZCBpcyBjb21wbGV0ZWQgKHVwbG9hZCBmaW5pc2hlZClcclxuICAgICovXHJcbiAgICBjb21wbGV0ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWVzc2FnZSB0byBkaXNwbGF5IHdoZW4gdXBsb2FkIGNvbXBsZXRlZFxyXG4gICAgICovXHJcbiAgICBjb21wbGV0ZWRNZXNzYWdlOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWVzIG9mIHRoZSBmaWxlcyB1cGxvYWRlZFxyXG4gICAgICovXHJcbiAgICBmaWxlTmFtZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlzdCBvZiBhbGxvd2VkIGZpbGUgdHlwZXMsIGUuZy4gWydqcGcnLCAncG5nJ11cclxuICAgICAqL1xyXG4gICAgZmlsZXR5cGVzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGFsbG93IGZpbGUgZHJhZyBhbmQgZHJvcFxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlRHJhZ0FuZERyb3A6IFByb3BUeXBlcy5ib29sLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGFzaC1hc3NpZ25lZCBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgYW55IG9mIHRoZVxyXG4gICAgICogcHJvcGVydGllcyBjaGFuZ2VcclxuICAgICAqL1xyXG4gICAgc2V0UHJvcHM6IFByb3BUeXBlcy5mdW5jXHJcblxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/components/Upload.react.js\n");

/***/ }),

/***/ "./src/lib/index.js":
/*!**************************!*\
  !*** ./src/lib/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Upload = undefined;\n\nvar _Upload = __webpack_require__(/*! ./components/Upload.react */ \"./src/lib/components/Upload.react.js\");\n\nvar _Upload2 = _interopRequireDefault(_Upload);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Upload = _Upload2.default; /* eslint-disable import/prefer-default-export *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvLi9zcmMvbGliL2luZGV4LmpzP2Q3NWEiXSwibmFtZXMiOlsiVXBsb2FkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7Ozs7OztRQUdJQSxNLEdBQUFBLGdCLEVBSkoiLCJmaWxlIjoiLi9zcmMvbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xyXG5pbXBvcnQgVXBsb2FkIGZyb20gJy4vY29tcG9uZW50cy9VcGxvYWQucmVhY3QnO1xyXG5cclxuZXhwb3J0IHtcclxuICAgIFVwbG9hZFxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/index.js\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"React\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZF9jb21wb25lbnQvZXh0ZXJuYWwgXCJSZWFjdFwiP2M0ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxrQ0FBa0MsRUFBRSIsImZpbGUiOiJyZWFjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJSZWFjdFwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react\n");

/***/ })

/******/ });